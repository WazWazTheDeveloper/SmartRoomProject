
emqx_authn_api {

authentication_get.desc:
"""List authenticators for global authentication."""
authentication_get.label:
"""List authenticators"""

authentication_id_delete.desc:
"""Delete authenticator from global authentication chain."""
authentication_id_delete.label:
"""Delete authenticator"""

authentication_id_get.desc:
"""Get authenticator from global authentication chain."""
authentication_id_get.label:
"""Get authenticator"""

authentication_id_position_put.desc:
"""Move authenticator in global authentication chain."""
authentication_id_position_put.label:
"""Move authenticator"""

authentication_id_put.desc:
"""Update authenticator from global authentication chain."""
authentication_id_put.label:
"""Update authenticator"""

authentication_id_status_get.desc:
"""Get authenticator status from global authentication chain."""
authentication_id_status_get.label:
"""Get authenticator status"""

authentication_id_users_get.desc:
"""List users in authenticator in global authentication chain."""
authentication_id_users_get.label:
"""List users in authenticator"""

authentication_id_users_post.desc:
"""Create users for authenticator in global authentication chain."""
authentication_id_users_post.label:
"""Create users for authenticator"""

authentication_id_users_user_id_delete.desc:
"""Delete user in authenticator in global authentication chain."""
authentication_id_users_user_id_delete.label:
"""Delete user in authenticator"""

authentication_id_users_user_id_get.desc:
"""Get user from authenticator in global authentication chain."""
authentication_id_users_user_id_get.label:
"""Get user from authenticator"""

authentication_id_users_user_id_put.desc:
"""Update user in authenticator in global authentication chain."""
authentication_id_users_user_id_put.label:
"""Update user in authenticator"""

authentication_post.desc:
"""Create authenticator for global authentication."""
authentication_post.label:
"""Create authenticator"""

is_superuser.desc:
"""Is superuser"""
is_superuser.label:
"""Is superuser"""

like_user_id.desc:
"""Fuzzy search user_id (username or clientid)."""

like_user_id.label:
"""like_user_id"""

listeners_listener_id_authentication_get.desc:
"""List authenticators for listener authentication."""
listeners_listener_id_authentication_get.label:
"""List authenticators for listener"""

listeners_listener_id_authentication_id_delete.desc:
"""Delete authenticator from listener authentication chain."""
listeners_listener_id_authentication_id_delete.label:
"""Delete authenticator from listener"""

listeners_listener_id_authentication_id_get.desc:
"""Get authenticator from listener authentication chain."""
listeners_listener_id_authentication_id_get.label:
"""Get authenticator from listener"""

listeners_listener_id_authentication_id_position_put.desc:
"""Move authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_position_put.label:
"""Move authenticator in listener"""

listeners_listener_id_authentication_id_put.desc:
"""Update authenticator from listener authentication chain."""
listeners_listener_id_authentication_id_put.label:
"""Update authenticator from listener"""

listeners_listener_id_authentication_id_status_get.desc:
"""Get authenticator status from listener authentication chain."""
listeners_listener_id_authentication_id_status_get.label:
"""Get authenticator status from listener"""

listeners_listener_id_authentication_id_users_get.desc:
"""List users in authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_users_get.label:
"""List users in authenticator in listener"""

listeners_listener_id_authentication_id_users_post.desc:
"""Create users for authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_users_post.label:
"""Create users for authenticator in listener"""

listeners_listener_id_authentication_id_users_user_id_delete.desc:
"""Delete user in authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_users_user_id_delete.label:
"""Delete user in authenticator in listener"""

listeners_listener_id_authentication_id_users_user_id_get.desc:
"""Get user from authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_users_user_id_get.label:
"""Get user from authenticator in listener"""

listeners_listener_id_authentication_id_users_user_id_put.desc:
"""Update user in authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_users_user_id_put.label:
"""Update user in authenticator in listener"""

listeners_listener_id_authentication_post.desc:
"""Create authenticator for listener authentication."""
listeners_listener_id_authentication_post.label:
"""Create authenticator for listener"""

param_auth_id.desc:
"""Authenticator ID."""
param_auth_id.label:
"""Authenticator ID"""

param_listener_id.desc:
"""Listener ID."""
param_listener_id.label:
"""Listener ID"""

param_position.desc:
"""Position of authenticator in chain. Possible values are 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'."""
param_position.label:
"""Position of authenticator"""

param_user_id.desc:
"""User ID."""
param_user_id.label:
"""User ID"""

}

emqx_authn_http {

body.desc:
"""HTTP request body."""

body.label:
"""Request Body"""

get.desc:
"""Configuration of authenticator using HTTP Server as authentication service (Using GET request)."""

headers.desc:
"""List of HTTP Headers."""

headers.label:
"""Headers"""

headers_no_content_type.desc:
"""List of HTTP headers (without <code>content-type</code>)."""

headers_no_content_type.label:
"""headers_no_content_type"""

method.desc:
"""HTTP request method."""

method.label:
"""Request Method"""

post.desc:
"""Configuration of authenticator using HTTP Server as authentication service (Using POST request)."""

request_timeout.desc:
"""HTTP request timeout."""

request_timeout.label:
"""Request Timeout"""

url.desc:
"""URL of the HTTP server."""

url.label:
"""URL"""

}

emqx_authn_jwt {

acl_claim_name.desc:
"""JWT claim name to use for getting ACL rules."""

acl_claim_name.label:
"""ACL claim name"""

algorithm.desc:
"""JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>)."""

algorithm.label:
"""JWT Signing Algorithm"""

cacertfile.desc:
"""Path to a file containing PEM-encoded CA certificates."""

cacertfile.label:
"""CA Certificate File"""

certfile.desc:
"""Path to a file containing the user certificate."""

certfile.label:
"""Certificate File"""

enable.desc:
"""Enable/disable SSL."""

enable.label:
"""Enable/disable SSL"""

endpoint.desc:
"""JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format."""

endpoint.label:
"""JWKS Endpoint"""

from.desc:
"""Field to take JWT from."""

from.label:
"""From Field"""

jwt_hmac.desc:
"""Configuration when the JWT for authentication is issued using the HMAC algorithm."""

jwt_jwks.desc:
"""Configuration when JWTs used for authentication need to be fetched from the JWKS endpoint."""

keyfile.desc:
"""Path to a file containing the user's private PEM-encoded key."""

keyfile.label:
"""Key File"""

jwt_public_key.desc:
"""Configuration when the JWT for authentication is issued using RSA or ECDSA algorithm."""

public_key.desc:
"""The public key used to verify the JWT."""

public_key.label:
"""Public Key"""

refresh_interval.desc:
"""JWKS refresh interval."""

refresh_interval.label:
"""JWKS Refresh Interval"""

secret.desc:
"""The key to verify the JWT using HMAC algorithm."""

secret.label:
"""Secret"""

secret_base64_encoded.desc:
"""Whether secret is base64 encoded."""

secret_base64_encoded.label:
"""Whether Secret is Base64 Encoded"""

server_name_indication.desc:
"""Server Name Indication (SNI)."""

server_name_indication.label:
"""Server Name Indication"""

ssl.desc:
"""SSL options."""

ssl.label:
"""SSL Options"""

use_jwks.desc:
"""Whether to use JWKS."""

use_jwks.label:
"""Whether to Use JWKS"""

verify.desc:
"""Enable or disable SSL peer verification."""

verify.label:
"""Verify"""

verify_claims.desc:
"""A list of custom claims to validate, which is a list of name/value pairs.
Values can use the following placeholders:
- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting
Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>."""

verify_claims.label:
"""Verify Claims"""

}

emqx_authn_mnesia {

builtin_db.desc:
"""Configuration of authenticator using built-in database as data source."""

user_id_type.desc:
"""Specify whether to use `clientid` or `username` for authentication."""

user_id_type.label:
"""Authentication ID Type"""

}

emqx_authn_mongodb {

collection.desc:
"""Collection used to store authentication data."""

collection.label:
"""Collection"""

filter.desc:
"""Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders:
- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting
- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting"""

filter.label:
"""Filter"""

is_superuser_field.desc:
"""Document field that defines if the user has superuser privileges."""

is_superuser_field.label:
"""Is Superuser Field"""

password_hash_field.desc:
"""Document field that contains password hash."""

password_hash_field.label:
"""Password Hash Field"""

replica-set.desc:
"""Configuration of authenticator using MongoDB (Replica Set) as authentication data source."""

salt_field.desc:
"""Document field that contains the password salt."""

salt_field.label:
"""Salt Field"""

sharded-cluster.desc:
"""Configuration of authenticator using MongoDB (Sharded Cluster) as authentication data source."""

single.desc:
"""Configuration of authenticator using MongoDB (Standalone) as authentication data source."""

}

emqx_authn_mysql {

mysql.desc:
"""Configuration of authenticator using MySQL as authentication data source."""

query.desc:
"""SQL used to query data for authentication, such as password hash."""

query.label:
"""Query"""

query_timeout.desc:
"""Timeout for the SQL query."""

query_timeout.label:
"""Query Timeout"""

}

emqx_authn_pgsql {

postgresql.desc:
"""Configuration of authenticator using PostgreSQL as authentication data source."""

query.desc:
"""SQL used to query data for authentication, such as password hash."""

query.label:
"""Query"""

}

emqx_authn_redis {

cluster.desc:
"""Configuration of authenticator using Redis (Cluster) as authentication data source."""

cmd.desc:
"""The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>."""

cmd.label:
"""Command"""

sentinel.desc:
"""Configuration of authenticator using Redis (Sentinel) as authentication data source."""

single.desc:
"""Configuration of authenticator using Redis (Standalone) as authentication data source."""

}

emqx_authn_schema {

backend.desc:
"""Backend type."""

backend.label:
"""Backend Type"""

enable.desc:
"""Set to <code>true</code> or <code>false</code> to disable this auth provider."""

enable.label:
"""Enable"""

failed.desc:
"""Count of query failed."""

failed.label:
"""Failed"""

matched.desc:
"""Count of this resource is queried."""

matched.label:
"""Matched"""

mechanism.desc:
"""Authentication mechanism."""

mechanism.label:
"""Authentication Mechanism"""

metrics.desc:
"""The metrics of the resource."""

metrics.label:
"""Metrics"""

metrics_failed.desc:
"""The required authentication information is found in the current instance, and the instance returns authentication failure."""

metrics_failed.label:
"""Authentication Failed Times"""

metrics_nomatch.desc:
"""The number of times the instance was ignored when the required authentication information was not found in the current instance."""

metrics_nomatch.label:
"""Nomatch Times"""

metrics_rate.desc:
"""The total rate at which instances are triggered, times/second."""

metrics_rate.label:
"""Total Triggered Rate"""

metrics_rate_last5m.desc:
"""The average trigger rate of the instance within 5 minutes, times/second."""

metrics_rate_last5m.label:
"""Average Triggered Rate in Last 5min"""

metrics_rate_max.desc:
"""The highest trigger rate the instance has ever reached, times/second."""

metrics_rate_max.label:
"""Highest Triggered Rate"""

metrics_success.desc:
"""The required authentication information is found in the current instance, and the instance returns authentication success."""

metrics_success.label:
"""Authentication Success Times"""

metrics_total.desc:
"""The total number of times the current instance was triggered."""

metrics_total.label:
"""Total Triggered Times"""

node.desc:
"""Node name."""

node.label:
"""Node Name."""

node_error.desc:
"""The error of node."""

node_error.label:
"""Error in Node"""

node_metrics.desc:
"""The metrics of the resource for each node."""

node_metrics.label:
"""Resource Metrics in Node"""

node_status.desc:
"""The status of the resource for each node."""

node_status.label:
"""Resource Status in Node"""

rate.desc:
"""The rate of matched, times/second."""

rate.label:
"""Rate"""

rate_last5m.desc:
"""The average rate of matched in the last 5 minutes, times/second."""

rate_last5m.label:
"""Rate in Last 5min"""

rate_max.desc:
"""The max rate of matched, times/second."""

rate_max.label:
"""Max Rate"""

status.desc:
"""The status of the resource."""

status.label:
"""Status"""

success.desc:
"""Count of query success."""

success.label:
"""Success"""

}

emqx_authn_user_import_api {

authentication_id_import_users_post.desc:
"""Import users into authenticator in global authentication chain."""
authentication_id_import_users_post.label:
"""Global import users into authenticator"""

listeners_listener_id_authentication_id_import_users_post.desc:
"""Import users into authenticator in listener authentication chain."""
listeners_listener_id_authentication_id_import_users_post.label:
"""Import users into authenticator in listener"""

}

emqx_authz_api_cache {

authorization_cache_delete.desc:
"""Clean all authorization cache in the cluster."""
authorization_cache_delete.label:
"""Clean authorization cache in cluster"""

}

emqx_authz_api_mnesia {

action.desc:
"""Authorized action (pub/sub/all)"""
action.label:
"""action"""

clientid.desc:
"""ClientID"""
clientid.label:
"""clientid"""

fuzzy_clientid.desc:
"""Fuzzy search `clientid` as substring"""

fuzzy_clientid.label:
"""fuzzy_clientid"""

fuzzy_username.desc:
"""Fuzzy search `username` as substring"""

fuzzy_username.label:
"""fuzzy_username"""

permission.desc:
"""Permission"""
permission.label:
"""permission"""

rules_all_delete.desc:
"""Delete rules for 'all'"""
rules_all_delete.label:
"""Delete rules for 'all'"""

rules_all_get.desc:
"""Show the list of rules for 'all'"""
rules_all_get.label:
"""Show rules for 'all'"""

rules_all_post.desc:
"""Create/Update the list of rules for 'all'."""
rules_all_post.label:
"""Update rules for 'all'"""

rules_delete.desc:
"""Delete all rules for all 'users', 'clients' and 'all'"""
rules_delete.label:
"""Delete all rules"""

topic.desc:
"""Rule on specific topic"""
topic.label:
"""topic"""

user_clientid_delete.desc:
"""Delete rule for 'clientid'"""
user_clientid_delete.label:
"""Delete rule for 'clientid'"""

user_clientid_get.desc:
"""Get rule for 'clientid'"""
user_clientid_get.label:
"""Get rule for 'clientid'"""

user_clientid_put.desc:
"""Set rule for 'clientid'"""
user_clientid_put.label:
"""Set rule for 'clientid'"""

user_username_delete.desc:
"""Delete rule for 'username'"""
user_username_delete.label:
"""Delete rule for 'username'"""

user_username_get.desc:
"""Get rule for 'username'"""
user_username_get.label:
"""Get rule for 'username'"""

user_username_put.desc:
"""Set rule for 'username'"""
user_username_put.label:
"""Set rule for 'username'"""

username.desc:
"""Username"""
username.label:
"""username"""

users_clientid_get.desc:
"""Show the list of rules for clients"""
users_clientid_get.label:
"""Show rules for clients"""

users_clientid_post.desc:
"""Add new rule for 'clientid'"""
users_clientid_post.label:
"""Add rule for 'clientid'"""

users_username_get.desc:
"""Show the list of rules for users"""
users_username_get.label:
"""Show rules for users"""

users_username_post.desc:
"""Add new rule for 'username'"""
users_username_post.label:
"""Add rule for 'username'"""

}

emqx_authz_api_schema {

body.desc:
"""HTTP request body."""

body.label:
"""body"""

cmd.desc:
"""Database query used to retrieve authorization data."""

cmd.label:
"""cmd"""

collection.desc:
"""`MongoDB` collection containing the authorization data."""

collection.label:
"""collection"""

enable.desc:
"""Set to <code>true</code> or <code>false</code> to disable this ACL provider."""

enable.label:
"""enable"""

filter.desc:
"""Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders:
 - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting;
 - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting."""

filter.label:
"""Filter"""

headers.desc:
"""List of HTTP Headers."""

headers.label:
"""Headers"""

headers_no_content_type.desc:
"""List of HTTP headers (without <code>content-type</code>)."""

headers_no_content_type.label:
"""headers_no_content_type"""

method.desc:
"""HTTP method."""

method.label:
"""method"""

position.desc:
"""Where to place the source."""

position.label:
"""position"""

query.desc:
"""Database query used to retrieve authorization data."""

query.label:
"""query"""

request_timeout.desc:
"""Request timeout."""

request_timeout.label:
"""request_timeout"""

rules.desc:
"""Authorization static file rules."""

rules.label:
"""rules"""

type.desc:
"""Backend type."""

type.label:
"""type"""

url.desc:
"""URL of the auth server."""

url.label:
"""url"""

}

emqx_authz_api_settings {

authorization_settings_get.desc:
"""Get authorization settings"""

authorization_settings_put.desc:
"""Update authorization settings"""

}

emqx_authz_api_sources {

authorization_sources_get.desc:
"""List all authorization sources"""
authorization_sources_get.label:
"""List all authorization sources"""

authorization_sources_post.desc:
"""Add a new source"""
authorization_sources_post.label:
"""Add a new source"""

authorization_sources_type_delete.desc:
"""Delete source"""
authorization_sources_type_delete.label:
"""Delete source"""

authorization_sources_type_get.desc:
"""Get a authorization source"""
authorization_sources_type_get.label:
"""Get a authorization source"""

authorization_sources_type_move_post.desc:
"""Change the exection order of sources"""
authorization_sources_type_move_post.label:
"""Change order of sources"""

authorization_sources_type_put.desc:
"""Update source"""
authorization_sources_type_put.label:
"""Update source"""

authorization_sources_type_status_get.desc:
"""Get a authorization source"""
authorization_sources_type_status_get.label:
"""Get a authorization source"""

source.desc:
"""Authorization source"""
source.label:
"""source"""

source_config.desc:
"""Source config"""
source_config.label:
"""source_config"""

source_type.desc:
"""Authorization type"""
source_type.label:
"""source_type"""

sources.desc:
"""Authorization sources"""
sources.label:
"""sources"""

}

emqx_authz_schema {

deny.desc:
"""The number of authentication failures."""

deny.label:
"""The Number of Authentication Failures"""

redis_sentinel.desc:
"""Authorization using a Redis Sentinel."""

redis_sentinel.label:
"""redis_sentinel"""

rate.desc:
"""The rate of matched, times/second."""

rate.label:
"""Rate"""

status.desc:
"""The status of the resource."""

status.label:
"""Status"""

method.desc:
"""HTTP method."""

method.label:
"""method"""

query.desc:
"""Database query used to retrieve authorization data."""

query.label:
"""query"""

metrics_total.desc:
"""The total number of times the authorization rule was triggered."""

metrics_total.label:
"""The Total Number of Times the Authorization Rule was Triggered"""

redis_cluster.desc:
"""Authorization using a Redis cluster."""

redis_cluster.label:
"""redis_cluster"""

mysql.desc:
"""Authorization using a MySQL database."""

mysql.label:
"""mysql"""

postgresql.desc:
"""Authorization using a PostgreSQL database."""

postgresql.label:
"""postgresql"""

mongo_rs.desc:
"""Authorization using a MongoDB replica set."""

mongo_rs.label:
"""mongo_rs"""

type.desc:
"""Backend type."""

type.label:
"""type"""

mongo_sharded.desc:
"""Authorization using a sharded MongoDB cluster."""

mongo_sharded.label:
"""mongo_sharded"""

body.desc:
"""HTTP request body."""

body.label:
"""Request Body"""

url.desc:
"""URL of the auth server."""

url.label:
"""URL"""

node.desc:
"""Node name."""

node.label:
"""Node Name."""

headers.desc:
"""List of HTTP Headers."""

headers.label:
"""Headers"""

rate_last5m.desc:
"""The average rate of matched in the last 5 minutes, times/second."""

rate_last5m.label:
"""Rate in Last 5min"""

headers_no_content_type.desc:
"""List of HTTP headers (without <code>content-type</code>)."""

headers_no_content_type.label:
"""headers_no_content_type"""

node_error.desc:
"""The error of node."""

node_error.label:
"""Error in Node"""

builtin_db.desc:
"""Authorization using a built-in database (mnesia)."""

builtin_db.label:
"""Builtin Database"""

enable.desc:
"""Set to <code>true</code> or <code>false</code> to disable this ACL provider"""

enable.label:
"""enable"""

matched.desc:
"""Count of this resource is queried."""

matched.label:
"""Matched"""

node_status.desc:
"""The status of the resource for each node."""

node_status.label:
"""Resource Status in Node"""

rate_max.desc:
"""The max rate of matched, times/second."""

rate_max.label:
"""Max Rate"""

filter.desc:
"""Conditional expression that defines the filter condition in the query.
Filter supports the following placeholders<br/>
 - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting<br/>
 - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting"""

filter.label:
"""Filter"""

path.desc:
"""Path to the file which contains the ACL rules.
If the file provisioned before starting EMQX node,
it can be placed anywhere as long as EMQX has read access to it.
That is, EMQX will treat it as read only.

In case the rule-set is created or updated from EMQX Dashboard or HTTP API,
a new file will be created and placed in `authz` subdirectory inside EMQX's `data_dir`,
and the old file will not be used anymore."""

path.label:
"""path"""

redis_single.desc:
"""Authorization using a single Redis instance."""

redis_single.label:
"""redis_single"""

failed.desc:
"""Count of query failed."""

failed.label:
"""Failed"""

metrics.desc:
"""The metrics of the resource."""

metrics.label:
"""Metrics"""

authorization.desc:
"""Configuration related to the client authorization."""

authorization.label:
"""authorization"""

collection.desc:
"""`MongoDB` collection containing the authorization data."""

collection.label:
"""collection"""

mongo_single.desc:
"""Authorization using a single MongoDB instance."""

mongo_single.label:
"""mongo_single"""

file.desc:
"""Authorization using a static file."""

file.label:
"""file"""

http_post.desc:
"""Authorization using an external HTTP server (via POST requests)."""

http_post.label:
"""http_post"""

request_timeout.desc:
"""HTTP request timeout."""

request_timeout.label:
"""Request Timeout"""

allow.desc:
"""The number of times the authentication was successful."""

allow.label:
"""The Number of Times the Authentication was Successful"""

cmd.desc:
"""Database query used to retrieve authorization data."""

cmd.label:
"""cmd"""

nomatch.desc:
"""The number of times that no authorization rules were matched."""

nomatch.label:
"""The Number of Times that no Authorization Rules were Matched"""

sources.desc:
"""Authorization data sources.<br/>
An array of authorization (ACL) data providers.
It is designed as an array, not a hash-map, so the sources can be
ordered to form a chain of access controls.<br/>

When authorizing a 'publish' or 'subscribe' action, the configured
sources are checked in order. When checking an ACL source,
in case the client (identified by username or client ID) is not found,
it moves on to the next source. And it stops immediately
once an 'allow' or 'deny' decision is returned.<br/>

If the client is not found in any of the sources,
the default action configured in 'authorization.no_match' is applied.<br/>

NOTE:
The source elements are identified by their 'type'.
It is NOT allowed to configure two or more sources of the same type."""

sources.label:
"""sources"""

node_metrics.desc:
"""The metrics of the resource for each node."""

node_metrics.label:
"""Resource Metrics in Node"""

success.desc:
"""Count of query success."""

success.label:
"""Success"""

http_get.desc:
"""Authorization using an external HTTP server (via GET requests)."""

http_get.label:
"""http_get"""

}

emqx_auto_subscribe_api {

list_auto_subscribe_api.desc:
"""Get auto subscribe topic list"""
list_auto_subscribe_api.label:
"""Get auto subscribe topics"""

update_auto_subscribe_api.desc:
"""Update auto subscribe topic list"""
update_auto_subscribe_api.label:
"""Update auto subscribe topics"""

update_auto_subscribe_api_response409.desc:
"""Auto Subscribe topics max limit"""
update_auto_subscribe_api_response409.label:
"""Auto Subscribe topics max limit"""

}

emqx_auto_subscribe_schema {

auto_subscribe.desc:
"""After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders."""

auto_subscribe.label:
"""Auto Subscribe"""

nl.desc:
"""Default value 0.
MQTT v3.1.1： if you subscribe to the topic published by yourself, you will receive all messages that you published.
MQTT v5: if you set this option as 1 when subscribing, the server will not forward the message you published to you."""

nl.label:
"""No Local"""

qos.desc:
"""Default value 0. Quality of service.
At most once (0)
At least once (1)
Exactly once (2)"""

qos.label:
"""Quality of Service"""

rap.desc:
"""Default value 0. This option is used to specify whether the server retains the RETAIN mark when forwarding messages to the client, and this option does not affect the RETAIN mark in the retained message. Therefore, when the option Retain As Publish is set to 0, the client will directly distinguish whether this is a normal forwarded message or a retained message according to the RETAIN mark in the message, instead of judging whether this message is the first received after subscribing(the forwarded message may be sent before the retained message, which depends on the specific implementation of different brokers)."""

rap.label:
"""Retain As Publish"""

rh.desc:
"""Default value 0. This option is used to specify whether the server forwards the retained message to the client when establishing a subscription.
Retain Handling is equal to 0, as long as the client successfully subscribes, the server will send the retained message.
Retain Handling is equal to 1, if the client successfully subscribes and this subscription does not exist previously, the server sends the retained message. After all, sometimes the client re-initiate the subscription just to change the QoS, but it does not mean that it wants to receive the reserved messages again.
Retain Handling is equal to 2, even if the client successfully subscribes, the server does not send the retained message."""

rh.label:
"""Retain Handling"""

topic.desc:
"""Topic name, placeholders are supported. For example: client/${clientid}/username/${username}/host/${host}/port/${port}
Required field, and cannot be empty string"""

topic.label:
"""Topic"""

}

emqx_bridge_api {

desc_api1.desc:
"""List all created bridges"""

desc_api1.label:
"""List All Bridges"""

desc_api2.desc:
"""Create a new bridge by type and name"""

desc_api2.label:
"""Create Bridge"""

desc_api3.desc:
"""Get a bridge by Id"""

desc_api3.label:
"""Get Bridge"""

desc_api4.desc:
"""Update a bridge by Id"""

desc_api4.label:
"""Update Bridge"""

desc_api5.desc:
"""Delete a bridge by Id"""

desc_api5.label:
"""Delete Bridge"""

desc_api6.desc:
"""Reset a bridge metrics by Id"""

desc_api6.label:
"""Reset Bridge Metrics"""

desc_api7.desc:
"""Stop/Restart bridges on all nodes in the cluster."""

desc_api7.label:
"""Cluster Bridge Operate"""

desc_api8.desc:
"""Stop/Restart bridges on a specific node."""

desc_api8.label:
"""Node Bridge Operate"""

desc_api9.desc:
"""Test creating a new bridge by given ID </br>
The ID must be of format '{type}:{name}'"""

desc_api9.label:
"""Test Bridge Creation"""

desc_bridge_metrics.desc:
"""Get bridge metrics by Id"""

desc_bridge_metrics.label:
"""Get Bridge Metrics"""

desc_enable_bridge.desc:
"""Enable or Disable bridges on all nodes in the cluster."""

desc_enable_bridge.label:
"""Cluster Bridge Enable"""

desc_param_path_enable.desc:
"""Whether to enable this bridge"""

desc_param_path_enable.label:
"""Enable bridge"""

desc_param_path_id.desc:
"""The bridge Id. Must be of format {type}:{name}"""

desc_param_path_id.label:
"""Bridge ID"""

desc_param_path_node.desc:
"""The node name, e.g. emqx@127.0.0.1"""

desc_param_path_node.label:
"""The node name"""

desc_param_path_operation_cluster.desc:
"""Operations can be one of: stop, restart"""

desc_param_path_operation_cluster.label:
"""Cluster Operation"""

desc_param_path_operation_on_node.desc:
"""Operations can be one of: stop, restart"""

desc_param_path_operation_on_node.label:
"""Node Operation """

}

emqx_bridge_cassandra {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

cql_template.desc:
"""CQL Template"""

cql_template.label:
"""CQL Template"""

desc_config.desc:
"""Configuration for a Cassandra bridge."""

desc_config.label:
"""Cassandra Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

}

emqx_bridge_cassandra_connector {

keyspace.desc:
"""Keyspace name to connect to."""

keyspace.label:
"""Keyspace"""

servers.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/>
The Cassandra default port 9042 is used if `[:Port]` is not specified."""

servers.label:
"""Servers"""

}

emqx_bridge_clickhouse {

batch_value_separator.desc:
"""The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)."""

batch_value_separator.label:
"""Batch Value Separator"""

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a Clickhouse bridge."""

desc_config.label:
"""Clickhouse Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

sql_template.desc:
"""The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported."""

sql_template.label:
"""SQL Template"""

}

emqx_bridge_clickhouse_connector {

base_url.desc:
"""The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)"""

base_url.label:
"""Server URL"""

connect_timeout.desc:
"""The timeout when connecting to the Clickhouse server."""

connect_timeout.label:
"""Clickhouse Timeout"""

}

emqx_bridge_dynamo {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a DynamoDB bridge."""

desc_config.label:
"""DynamoDB Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic
matching the `local_topic` will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is
configured, then both the data got from the rule and the MQTT messages that match `local_topic`
will be forwarded."""

local_topic.label:
"""Local Topic"""

template.desc:
"""Template, the default value is empty. When this value is empty the whole message will be stored in the database"""

template.label:
"""Template"""

}

emqx_bridge_dynamo_connector {

aws_access_key_id.desc:
"""Access Key ID for connecting to DynamoDB."""

aws_access_key_id.label:
"""AWS Access Key ID"""

aws_secret_access_key.desc:
"""AWS Secret Access Key for connecting to DynamoDB."""

aws_secret_access_key.label:
"""AWS Secret Access Key"""

table.desc:
"""DynamoDB Table."""

table.label:
"""Table """

url.desc:
"""The url of DynamoDB endpoint."""

url.label:
"""DynamoDB Endpoint"""

}

emqx_bridge_gcp_pubsub {

connect_timeout.desc:
"""The timeout when connecting to the HTTP server."""

connect_timeout.label:
"""Connect Timeout"""

desc_config.desc:
"""Configuration for a GCP PubSub bridge."""

desc_config.label:
"""GCP PubSub Bridge Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic
matching `local_topic` will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

max_retries.desc:
"""Max retry times if an error occurs when sending a request."""

max_retries.label:
"""Max Retries"""

payload_template.desc:
"""The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format."""

payload_template.label:
"""Payload template"""

pipelining.desc:
"""A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request."""

pipelining.label:
"""HTTP Pipelineing"""

pool_size.desc:
"""The pool size."""

pool_size.label:
"""Pool Size"""

pubsub_topic.desc:
"""The GCP PubSub topic to publish messages to."""

pubsub_topic.label:
"""GCP PubSub Topic"""

service_account_json.desc:
"""JSON containing the GCP Service Account credentials to be used with PubSub.
When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."""

service_account_json.label:
"""GCP Service Account Credentials"""

  consumer_opts {
    desc: "Local MQTT publish and GCP PubSub consumer configs."
    label: "GCP PubSub to MQTT"
  }

  consumer_pull_max_messages {
    desc: "The maximum number of messages to retrieve from GCP PubSub in a single pull request."
          " The actual number may be less than the specified value."
    label: "Maximum Messages to Pull"
  }

  consumer_topic_mapping {
    desc: "Defines the mapping between GCP PubSub topics and MQTT topics. Must contain at least one item."
    label: "Topic Mapping"
  }

  consumer_pubsub_topic {
    desc: "GCP PubSub topic to consume from."
    label: "GCP PubSub"
  }

  consumer_mqtt_topic {
    desc: "Local topic to which consumed GCP PubSub messages should be published to."
    label: "MQTT Topic"
  }

  consumer_mqtt_qos {
    desc: "MQTT QoS used to publish messages consumed from GCP PubSub."
    label: "QoS"
  }

consumer_mqtt_payload.desc:
"""The template for transforming the incoming GCP PubSub message.  By default, it will use JSON format to serialize inputs from the GCP PubSub message.  Available fields are:
<code>message_id</code>: the message ID assigned by GCP PubSub.
<code>publish_time</code>: message timestamp assigned by GCP PubSub.
<code>topic</code>: GCP PubSub topic.
<code>value</code>: the payload of the GCP PubSub message.  Omitted if there's no payload.
<code>attributes</code>: an object containing string key-value pairs.  Omitted if there are no attributes.
<code>ordering_key</code>: GCP PubSub message ordering key.  Omitted if there's none."""

consumer_mqtt_payload.label:
"Payload Template"

  consumer {
    desc: "GCP PubSub Consumer configuration."
    label: "GCP PubSub Consumer"
  }

}

emqx_bridge_influxdb {

config_enable.desc:
"""Enable or disable this bridge."""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for an InfluxDB bridge."""

desc_config.label:
"""InfluxDB Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type."""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

write_syntax.desc:
"""Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.
See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and
[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br>
TLDR:</br>
```
<measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]
```
Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."""

write_syntax.label:
"""Write Syntax"""

}

emqx_bridge_influxdb_connector {

bucket.desc:
"""InfluxDB bucket name."""

bucket.label:
"""Bucket"""

database.desc:
"""InfluxDB database."""

database.label:
"""Database"""

influxdb_api_v1.desc:
"""InfluxDB's protocol. Support InfluxDB v1.8 and before."""

influxdb_api_v1.label:
"""HTTP API Protocol"""

influxdb_api_v2.desc:
"""InfluxDB's protocol. Support InfluxDB v2.0 and after."""

influxdb_api_v2.label:
"""HTTP API V2 Protocol"""

org.desc:
"""Organization name of InfluxDB."""

org.label:
"""Organization"""

password.desc:
"""InfluxDB password."""

password.label:
"""Password"""

precision.desc:
"""InfluxDB time precision."""

precision.label:
"""Time Precision"""

protocol.desc:
"""InfluxDB's protocol. HTTP API or HTTP API V2."""

protocol.label:
"""Protocol"""

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.</br>
A host entry has the following form: `Host[:Port]`.</br>
The InfluxDB default port 8086 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

token.desc:
"""InfluxDB token."""

token.label:
"""Token"""

username.desc:
"""InfluxDB username."""

username.label:
"""Username"""

}

emqx_bridge_iotdb {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

config_authentication.desc:
"""Authentication configuration"""

config_authentication.label:
"""Authentication"""

auth_basic.desc:
"""Parameters for basic authentication."""

auth_basic.label:
"""Basic auth params"""

config_auth_basic_username.desc:
"""The username as configured at the IoTDB REST interface"""

config_auth_basic_username.label:
  """HTTP Basic Auth Username"""

config_auth_basic_password.desc:
"""The password as configured at the IoTDB REST interface"""

config_auth_basic_password.label:
"""HTTP Basic Auth Password"""

config_base_url.desc:
"""The base URL of the external IoTDB service's REST interface."""
config_base_url.label:
"""IoTDB REST Service Base URL"""

config_is_aligned.desc:
"""Whether to align the timeseries"""

config_is_aligned.label:
"""Align Timeseries"""

config_device_id.desc:
"""The IoTDB device ID this data should be inserted for.
If left empty, the MQTT message payload must contain a `device_id` field,
or EMQX's rule-engine SQL must produce a `device_id` field."""
config_device_id.label:
"""Device ID"""

config_iotdb_version.desc:
"""The version of the IoTDB system to connect to."""
config_iotdb_version.label:
"""IoTDB Version"""

config_max_retries.desc:
"""HTTP request max retry times if failed."""

config_max_retries.label:
"""HTTP Request Max Retries"""

desc_config.desc:
"""Configuration for Apache IoTDB bridge."""

desc_config.label:
"""IoTDB Bridge Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""
}

emqx_bridge_kafka {

connect_timeout.desc:
"""Maximum wait time for TCP connection establishment (including authentication time if enabled)."""

connect_timeout.label:
"""Connect Timeout"""

producer_opts.desc:
"""Local MQTT data source and Kafka bridge configs."""

producer_opts.label:
"""MQTT to Kafka"""

min_metadata_refresh_interval.desc:
"""Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka."""

min_metadata_refresh_interval.label:
"""Min Metadata Refresh Interval"""

kafka_producer.desc:
"""Kafka Producer configuration."""

kafka_producer.label:
"""Kafka Producer"""

producer_buffer.desc:
"""Configure producer message buffer.

Tell Kafka producer how to buffer messages when EMQX has more messages to send than Kafka can keep up, or when Kafka is down."""

producer_buffer.label:
"""Message Buffer"""

socket_send_buffer.desc:
"""Fine tune the socket send buffer. The default value is tuned for high throughput."""

socket_send_buffer.label:
"""Socket Send Buffer Size"""

socket_receive_buffer.desc:
"""Fine tune the socket receive buffer. The default value is tuned for high throughput."""

socket_receive_buffer.label:
"""Socket Receive Buffer Size"""

socket_tcp_keepalive.desc:
"""Enable TCP keepalive for Kafka bridge connections.
The value is three comma separated numbers in the format of 'Idle,Interval,Probes'
 - Idle: The number of seconds a connection needs to be idle before the server begins to send out keep-alive probes (Linux default 7200).
 - Interval: The number of seconds between TCP keep-alive probes (Linux default 75).
 - Probes: The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end (Linux default 9).
For example "240,30,5" means: TCP keepalive probes are sent after the connection is idle for 240 seconds, and the probes are sent every 30 seconds until a response is received, if it misses 5 consecutive responses, the connection should be closed.
Default: 'none'"""

socket_tcp_keepalive.label:
"""TCP keepalive options"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

consumer_offset_commit_interval_seconds.desc:
"""Defines the time interval between two offset commit requests sent for each consumer group."""

consumer_offset_commit_interval_seconds.label:
"""Offset Commit Interval"""

consumer_max_batch_bytes.desc:
"""Set how many bytes to pull from Kafka in each fetch request. Please note that if the configured value is smaller than the message size in Kafka, it may negatively impact the fetch performance."""

consumer_max_batch_bytes.label:
"""Fetch Bytes"""

consumer_topic_mapping.desc:
"""Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item."""

consumer_topic_mapping.label:
"""Topic Mapping"""

producer_kafka_opts.desc:
"""Kafka producer configs."""

producer_kafka_opts.label:
"""Kafka Producer"""

kafka_topic.desc:
"""Kafka topic name"""

kafka_topic.label:
"""Kafka Topic Name"""

consumer_kafka_topic.desc:
"""Kafka topic to consume from."""

consumer_kafka_topic.label:
"""Kafka Topic"""

auth_username_password.desc:
"""Username/password based authentication."""

auth_username_password.label:
"""Username/password Auth"""

auth_sasl_password.desc:
"""SASL authentication password."""

auth_sasl_password.label:
"""Password"""

kafka_message_timestamp.desc:
"""Which timestamp to use. The timestamp is expected to be a millisecond precision Unix epoch which can be in string format, e.g. <code>1661326462115</code> or <code>'1661326462115'</code>. When the desired data field for this template is not found, or if the found data is not a valid integer, the current system timestamp will be used."""

kafka_message_timestamp.label:
"""Message Timestamp"""

buffer_mode.desc:
"""Message buffer mode.

<code>memory</code>: Buffer all messages in memory. The messages will be lost in case of EMQX node restart
<code>disk</code>: Buffer all messages on disk. The messages on disk are able to survive EMQX node restart.
<code>hybrid</code>: Buffer message in memory first, when up to certain limit (see <code>segment_bytes</code> config for more information), then start offloading messages to disk, Like <code>memory</code> mode, the messages will be lost in case of EMQX node restart."""

buffer_mode.label:
"""Buffer Mode"""

consumer_mqtt_qos.desc:
"""MQTT QoS used to publish messages consumed from Kafka."""

consumer_mqtt_qos.label:
"""QoS"""

consumer_key_encoding_mode.desc:
"""Defines how the key from the Kafka message is encoded before being forwarded via MQTT.
<code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.
<code>base64</code> Uses base-64 encoding on the received key."""

consumer_key_encoding_mode.label:
"""Key Encoding Mode"""

auth_gssapi_kerberos.desc:
"""Use GSSAPI/Kerberos authentication."""

auth_gssapi_kerberos.label:
"""GSSAPI/Kerberos"""

consumer_mqtt_opts.desc:
"""Local MQTT message publish."""

consumer_mqtt_opts.label:
"""MQTT publish"""

auth_kerberos_principal.desc:
"""SASL GSSAPI authentication Kerberos principal. For example <code>client_name@MY.KERBEROS.REALM.MYDOMAIN.COM</code>, NOTE: The realm in use has to be configured in /etc/krb5.conf in EMQX nodes."""

auth_kerberos_principal.label:
"""Kerberos Principal"""

socket_opts.desc:
"""Extra socket options."""

socket_opts.label:
"""Socket Options"""

consumer_mqtt_topic.desc:
"""Local topic to which consumed Kafka messages should be published to."""

consumer_mqtt_topic.label:
"""MQTT Topic"""

consumer_offset_reset_policy.desc:
"""Defines from which offset a consumer should start fetching when there is no commit history or when the commit history becomes invalid."""

consumer_offset_reset_policy.label:
"""Offset Reset Policy"""

partition_count_refresh_interval.desc:
"""The time interval for Kafka producer to discover increased number of partitions.
After the number of partitions is increased in Kafka, EMQX will start taking the
discovered partitions into account when dispatching messages per <code>partition_strategy</code>."""

partition_count_refresh_interval.label:
"""Partition Count Refresh Interval"""

max_batch_bytes.desc:
"""Maximum bytes to collect in a Kafka message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch)."""

max_batch_bytes.label:
"""Max Batch Bytes"""

required_acks.desc:
"""Required acknowledgements for Kafka partition leader to wait for its followers before it sends back the acknowledgement to EMQX Kafka producer

<code>all_isr</code>: Require all in-sync replicas to acknowledge.
<code>leader_only</code>: Require only the partition-leader's acknowledgement.
<code>none</code>: No need for Kafka to acknowledge at all."""

required_acks.label:
"""Required Acks"""

kafka_headers.desc:
"""Please provide a placeholder to be used as Kafka Headers<br/>
e.g. <code>${pub_props}</code><br/>
Notice that the value of the placeholder must either be an object:
<code>{\"foo\": \"bar\"}</code>
or an array of key-value pairs:
<code>[{\"key\": \"foo\", \"value\": \"bar\"}]</code>"""

kafka_headers.label:
"""Kafka Headers"""

producer_kafka_ext_headers.desc:
"""Please provide more key-value pairs for Kafka headers<br/>
The key-value pairs here will be combined with the
value of <code>kafka_headers</code> field before sending to Kafka."""

producer_kafka_ext_headers.label:
"""Extra Kafka headers"""

producer_kafka_ext_header_key.desc:
"""Key of the Kafka header. Placeholders in format of ${var} are supported."""

producer_kafka_ext_header_key.label:
"""Kafka extra header key."""

producer_kafka_ext_header_value.desc:
"""Value of the Kafka header. Placeholders in format of ${var} are supported."""

producer_kafka_ext_header_value.label:
"""Value"""

kafka_header_value_encode_mode.desc:
"""Kafka headers value encode mode<br/>
 - NONE: only add binary values to Kafka headers;<br/>
 - JSON: only add JSON values to Kafka headers,
and encode it to JSON strings before sending."""

kafka_header_value_encode_mode.label:
"""Kafka headers value encode mode"""

metadata_request_timeout.desc:
"""Maximum wait time when fetching metadata from Kafka."""

metadata_request_timeout.label:
"""Metadata Request Timeout"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

socket_nodelay.desc:
"""When set to 'true', TCP buffer is sent as soon as possible. Otherwise, the OS kernel may buffer small TCP packets for a while (40 ms by default)."""

socket_nodelay.label:
"""No Delay"""

authentication.desc:
"""Authentication configs."""

authentication.label:
"""Authentication"""

buffer_memory_overload_protection.desc:
"""Applicable when buffer mode is set to <code>memory</code>
EMQX will drop old buffered messages under high memory pressure. The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>. NOTE: This config only works on Linux."""

buffer_memory_overload_protection.label:
"""Memory Overload Protection"""

auth_sasl_mechanism.desc:
"""SASL authentication mechanism."""

auth_sasl_mechanism.label:
"""Mechanism"""

config_enable.desc:
"""Enable (true) or disable (false) this Kafka bridge."""

config_enable.label:
"""Enable or Disable"""

consumer_mqtt_payload.desc:
"""The template for transforming the incoming Kafka message.  By default, it will use JSON format to serialize inputs from the Kafka message.  Such fields are:
<code>headers</code>: an object containing string key-value pairs.
<code>key</code>: Kafka message key (uses the chosen key encoding).
<code>offset</code>: offset for the message.
<code>topic</code>: Kafka topic.
<code>ts</code>: message timestamp.
<code>ts_type</code>: message timestamp type, which is one of <code>create</code>, <code>append</code> or <code>undefined</code>.
<code>value</code>: Kafka message value (uses the chosen value encoding)."""

consumer_mqtt_payload.label:
"""MQTT Payload Template"""

consumer_opts.desc:
"""Local MQTT publish and Kafka consumer configs."""

consumer_opts.label:
"""MQTT to Kafka"""

kafka_consumer.desc:
"""Kafka Consumer configuration."""

kafka_consumer.label:
"""Kafka Consumer"""

desc_config.desc:
"""Configuration for a Kafka bridge."""

desc_config.label:
"""Kafka Bridge Configuration"""

consumer_value_encoding_mode.desc:
"""Defines how the value from the Kafka message is encoded before being forwarded via MQTT.
<code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.
<code>base64</code> Uses base-64 encoding on the received value."""

consumer_value_encoding_mode.label:
"""Value Encoding Mode"""

buffer_per_partition_limit.desc:
"""Number of bytes allowed to buffer for each Kafka partition. When this limit is exceeded, old messages will be dropped in a trade for credits for new messages to be buffered."""

buffer_per_partition_limit.label:
"""Per-partition Buffer Limit"""

bootstrap_hosts.desc:
"""A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."""

bootstrap_hosts.label:
"""Bootstrap Hosts"""

consumer_max_rejoin_attempts.desc:
"""Maximum number of times allowed for a member to re-join the group. If the consumer group can not reach balance after this configured number of attempts, the consumer group member will restart after a delay."""

consumer_max_rejoin_attempts.label:
"""Max Rejoin Attempts"""

kafka_message_key.desc:
"""Template to render Kafka message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used."""

kafka_message_key.label:
"""Message Key"""

kafka_message.desc:
"""Template to render a Kafka message."""

kafka_message.label:
"""Kafka Message Template"""

mqtt_topic.desc:
"""MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."""

mqtt_topic.label:
"""Source MQTT Topic"""

kafka_message_value.desc:
"""Template to render Kafka message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used."""

kafka_message_value.label:
"""Message Value"""

partition_strategy.desc:
"""Partition strategy is to tell the producer how to dispatch messages to Kafka partitions.

<code>random</code>: Randomly pick a partition for each message
<code>key_dispatch</code>: Hash Kafka message key to a partition number"""

partition_strategy.label:
"""Partition Strategy"""

buffer_segment_bytes.desc:
"""Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.
This value is to specify the size of each on-disk buffer file."""

buffer_segment_bytes.label:
"""Segment File Bytes"""

consumer_kafka_opts.desc:
"""Kafka consumer configs."""

consumer_kafka_opts.label:
"""Kafka Consumer"""

max_inflight.desc:
"""Maximum number of batches allowed for Kafka producer (per-partition) to send before receiving acknowledgement from Kafka. Greater value typically means better throughput. However, there can be a risk of message reordering when this value is greater than 1."""

max_inflight.label:
"""Max Inflight"""

auth_sasl_username.desc:
"""SASL authentication username."""

auth_sasl_username.label:
"""Username"""

auth_kerberos_keytab_file.desc:
"""SASL GSSAPI authentication Kerberos keytab file path. NOTE: This file has to be placed in EMQX nodes, and the EMQX service runner user requires read permission."""

auth_kerberos_keytab_file.label:
"""Kerberos keytab file"""

compression.desc:
"""Compression method."""

compression.label:
"""Compression"""

query_mode.desc:
"""Query mode. Optional 'sync/async', default 'async'."""

query_mode.label:
"""Query mode"""

sync_query_timeout.desc:
"""This parameter defines the timeout limit for synchronous queries. It applies only when the bridge query mode is configured to 'sync'."""

sync_query_timeout.label:
"""Synchronous Query Timeout"""

}

emqx_bridge_mongodb {

collection.desc:
"""The collection where data will be stored into"""

collection.label:
"""Collection to be used"""

desc_config.desc:
"""Configuration for MongoDB Bridge"""

desc_config.label:
"""MongoDB Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type."""

desc_type.label:
"""Bridge Type"""

enable.desc:
"""Enable or disable this MongoDB Bridge"""

enable.label:
"""Enable or disable"""

mongodb_rs_conf.desc:
"""MongoDB (Replica Set) configuration"""

mongodb_rs_conf.label:
"""MongoDB (Replica Set) Configuration"""

mongodb_sharded_conf.desc:
"""MongoDB (Sharded) configuration"""

mongodb_sharded_conf.label:
"""MongoDB (Sharded) Configuration"""

mongodb_single_conf.desc:
"""MongoDB (Standalone) configuration"""

mongodb_single_conf.label:
"""MongoDB (Standalone) Configuration"""

payload_template.desc:
"""The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."""

payload_template.label:
"""Payload template"""

batch_size.desc:
"""There is no batching support for MongoDB at the moment, so this config field has no effect. Internally the value is overridden to 1."""
batch_size.label:
"""Batch Size"""

}

emqx_bridge_mqtt_connector_schema {

bridge_mode.desc:
"""If enable bridge mode.
NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT
broker MUST support this feature.
If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.
This means that loop detection will be more effective and that retained messages will be propagated correctly."""

bridge_mode.label:
"""Bridge Mode"""

clean_start.desc:
"""Whether to start a clean session when reconnecting a remote broker for ingress bridge"""

clean_start.label:
"""Clean Session"""

clientid_prefix.desc:
"""Optional prefix to prepend to the clientid used by egress bridges."""

clientid_prefix.label:
"""Clientid Prefix"""

egress_desc.desc:
"""The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/>
Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/>
NOTE: if this bridge is used as the action of a rule, and also 'local.topic'
is configured, then both the data got from the rule and the MQTT messages that matches
'local.topic' will be forwarded."""

egress_desc.label:
"""Egress Configs"""

egress_pool_size.desc:
"""Size of the pool of MQTT clients that will publish messages to the remote broker.<br/>
Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:egress:${node}:${n}'
where 'n' is the number of a client inside the pool."""

egress_pool_size.label:
"""Pool Size"""

egress_local.desc:
"""The configs about receiving messages from local broker."""

egress_local.label:
"""Local Configs"""

egress_local_topic.desc:
"""The local topic to be forwarded to the remote broker"""

egress_local_topic.label:
"""Local Topic"""

egress_remote.desc:
"""The configs about sending message to the remote broker."""

egress_remote.label:
"""Remote Configs"""

egress_remote_qos.desc:
"""The QoS of the MQTT message to be sent.<br/>
Template with variables is allowed."""

egress_remote_qos.label:
"""Remote QoS"""

egress_remote_topic.desc:
"""Forward to which topic of the remote broker.<br/>
Template with variables is allowed."""

egress_remote_topic.label:
"""Remote Topic"""

ingress_desc.desc:
"""The ingress config defines how this bridge receive messages from the remote MQTT broker, and then
        send them to the local broker.<br/>
        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/>
        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is
        configured, then messages got from the remote broker will be sent to both the 'local.topic' and
        the rule."""

ingress_desc.label:
"""Ingress Configs"""

ingress_pool_size.desc:
"""Size of the pool of MQTT clients that will ingest messages from the remote broker.<br/>
This value will be respected only if 'remote.topic' is a shared subscription topic or topic-filter
(for example `$share/name1/topic1` or `$share/name2/topic2/#`), otherwise only a single MQTT client will be used.
Each MQTT client will be assigned 'clientid' of the form '${clientid_prefix}:${bridge_name}:ingress:${node}:${n}'
where 'n' is the number of a client inside the pool.
NOTE: Non-shared subscription will not work well when EMQX is clustered."""

ingress_pool_size.label:
"""Pool Size"""

ingress_local.desc:
"""The configs about sending message to the local broker."""

ingress_local.label:
"""Local Configs"""

ingress_local_qos.desc:
"""The QoS of the MQTT message to be sent.<br/>
Template with variables is allowed."""

ingress_local_qos.label:
"""Local QoS"""

ingress_local_topic.desc:
"""Send messages to which topic of the local broker.<br/>
Template with variables is allowed."""

ingress_local_topic.label:
"""Local Topic"""

ingress_remote.desc:
"""The configs about subscribing to the remote broker."""

ingress_remote.label:
"""Remote Configs"""

ingress_remote_qos.desc:
"""The QoS level to be used when subscribing to the remote broker"""

ingress_remote_qos.label:
"""Remote QoS"""

ingress_remote_topic.desc:
"""Receive messages from which topic of the remote broker"""

ingress_remote_topic.label:
"""Remote Topic"""

max_inflight.desc:
"""Max inflight (sent, but un-acked) messages of the MQTT protocol"""

max_inflight.label:
"""Max Inflight Message"""

mode.desc:
"""The mode of the MQTT Bridge.<br/>
- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/>
In 'cluster_shareload' mode, the incoming load from the remote broker is shared by
using shared subscription.<br/>
Note that the 'clientid' is suffixed by the node name, this is to avoid
clientid conflicts between different nodes. And we can only use shared subscription
topic filters for <code>remote.topic</code> of ingress connections."""

mode.label:
"""MQTT Bridge Mode"""

password.desc:
"""The password of the MQTT protocol"""

password.label:
"""Password"""

payload.desc:
"""The payload of the MQTT message to be sent.<br/>
Template with variables is allowed."""

payload.label:
"""Payload"""

proto_ver.desc:
"""The MQTT protocol version"""

proto_ver.label:
"""Protocol Version"""

retain.desc:
"""The 'retain' flag of the MQTT message to be sent.<br/>
Template with variables is allowed."""

retain.label:
"""Retain Flag"""

server.desc:
"""The host and port of the remote MQTT broker"""

server.label:
"""Broker IP And Port"""

server_configs.desc:
"""Configs related to the server."""

server_configs.label:
"""Server Configs"""

username.desc:
"""The username of the MQTT protocol"""

username.label:
"""Username"""

}

emqx_bridge_mqtt_schema {

config.desc:
"""The config for MQTT Bridges."""

config.label:
"""Config"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The bridge type."""

desc_type.label:
"""Bridge Type"""

}

emqx_bridge_mysql {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for an HStreamDB bridge."""

desc_config.label:
"""HStreamDB Bridge Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

sql_template.desc:
"""SQL Template"""

sql_template.label:
"""SQL Template"""

}

emqx_bridge_opents {

    config_enable.desc:
        """Enable or disable this bridge"""

    config_enable.label:
        "Enable Or Disable Bridge"

    desc_config.desc:
        """Configuration for an OpenTSDB bridge."""

    desc_config.label:
        "OpenTSDB Bridge Configuration"

    desc_type.desc:
        """The Bridge Type"""

    desc_type.label:
        "Bridge Type"

    desc_name.desc:
        """Bridge name."""

    desc_name.label:
        "Bridge Name"
}

emqx_bridge_opents_connector {

    server.desc:
        """The URL of OpenTSDB endpoint."""

    server.label:
        "URL"

    summary.desc:
        """Whether to return summary information."""

    summary.label:
        "Summary"

    details.desc:
        """Whether to return detailed information."""

    details.label:
        "Details"
}

emqx_bridge_oracle {

  local_topic {
    desc = "The MQTT topic filter to be forwarded to Oracle Database. All MQTT 'PUBLISH' messages with the topic"
           " matching the local_topic will be forwarded.</br>"
           "NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is"
           " configured, then both the data got from the rule and the MQTT messages that match local_topic"
           " will be forwarded."
    label = "Local Topic"
  }

  sql_template {
    desc = "SQL Template. The template string can contain placeholders"
           " for message metadata and payload field. The placeholders are inserted"
           " without any checking and special formatting, so it is important to"
           " ensure that the inserted values are formatted and escaped correctly."
    label = "SQL Template"
  }

  server {
    desc = "The IPv4 or IPv6 address or the hostname to connect to.<br/>"
           "A host entry has the following form: `Host[:Port]`.<br/>"
           "The Oracle Database default port 1521 is used if `[:Port]` is not specified."
    label = "Server Host"
  }

  sid {
    desc = "Sid for Oracle Database"
    label = "Oracle Database Sid."
  }

  service_name {
    desc = "Service Name for Oracle Database."
    label = "Oracle Database Service Name"
  }

  config_enable {
    desc = "Enable or disable this bridge"
    label = "Enable Or Disable Bridge"
  }

  desc_config {
    desc = "Configuration for an Oracle Database bridge."
    label = "Oracle Database Bridge Configuration"
  }

  desc_type {
    desc = "The Bridge Type"
    label = "Bridge Type"
  }

  desc_name {
    desc = "Bridge name."
    label = "Bridge Name"
  }

}

emqx_bridge_pgsql {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a PostgreSQL bridge."""

desc_config.label:
"""PostgreSQL Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

sql_template.desc:
"""SQL Template"""

sql_template.label:
"""SQL Template"""

}

emqx_bridge_pulsar {
  auth_basic {
    desc = "Parameters for basic authentication."
    label = "Basic auth params"
  }

  auth_basic_password {
    desc = "Basic authentication password."
    label = "Password"
  }

  auth_basic_username {
    desc = "Basic authentication username."
    label = "Username"
  }

  auth_token {
    desc = "Parameters for token authentication."
    label = "Token auth params"
  }

  auth_token_jwt {
    desc = "JWT authentication token."
    label = "JWT"
  }

  authentication {
    desc = "Authentication configs."
    label = "Authentication"
  }

  buffer_memory_overload_protection {
    desc = "Applicable when buffer mode is set to <code>memory</code>\n"
           "EMQX will drop old buffered messages under high memory pressure."
           " The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>."
           " NOTE: This config only works on Linux."
    label = "Memory Overload Protection"
  }

  buffer_mode {
    desc = "Message buffer mode.\n"
           "<code>memory</code>: Buffer all messages in memory. The messages will be lost"
           " in case of EMQX node restart\n<code>disk</code>: Buffer all messages on disk."
           " The messages on disk are able to survive EMQX node restart.\n"
           "<code>hybrid</code>: Buffer message in memory first, when up to certain limit"
           " (see <code>segment_bytes</code> config for more information), then start offloading"
           " messages to disk, Like <code>memory</code> mode, the messages will be lost in"
           " case of EMQX node restart."
    label = "Buffer Mode"
  }

  buffer_per_partition_limit {
    desc = "Number of bytes allowed to buffer for each Pulsar partition."
           " When this limit is exceeded, old messages will be dropped in a trade for credits"
           " for new messages to be buffered."
    label = "Per-partition Buffer Limit"
  }

  buffer_segment_bytes {
    desc = "Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.\n"
           "This value is to specify the size of each on-disk buffer file."
    label = "Segment File Bytes"
  }

  config_enable {
    desc = "Enable (true) or disable (false) this Pulsar bridge."
    label = "Enable or Disable"
  }

  connect_timeout {
    desc = "Maximum wait time for TCP connection establishment (including authentication time if enabled)."
    label = "Connect Timeout"
  }

  desc_name {
    desc = "Bridge name, used as a human-readable description of the bridge."
    label = "Bridge Name"
  }

  desc_type {
    desc = "The Bridge Type"
    label = "Bridge Type"
  }

  producer_batch_size {
    desc = "Maximum number of individual requests to batch in a Pulsar message."
    label = "Batch size"
  }

  producer_buffer {
    desc = "Configure producer message buffer.\n\n"
           "Tell Pulsar producer how to buffer messages when EMQX has more messages to"
           " send than Pulsar can keep up, or when Pulsar is down."
    label = "Message Buffer"
  }

  producer_compression {
    desc = "Compression method."
    label = "Compression"
  }

  producer_key_template {
    desc = "Template to render Pulsar message key."
    label = "Message Key"
  }

  producer_local_topic {
    desc = "MQTT topic or topic filter as data source (bridge input)."
           " If rule action is used as data source, this config should be left empty,"
           " otherwise messages will be duplicated in Pulsar."
    label = "Source MQTT Topic"
  }

  producer_max_batch_bytes {
    desc = "Maximum bytes to collect in a Pulsar message batch. Most of the Pulsar brokers"
           " default to a limit of 5 MB batch size. EMQX's default value is less than 5 MB in"
           " order to compensate Pulsar message encoding overheads (especially when each individual"
           " message is very small). When a single message is over the limit, it is still"
           " sent (as a single element batch)."
    label = "Max Batch Bytes"
  }

  producer_message_opts {
    desc = "Template to render a Pulsar message."
    label = "Pulsar Message Template"
  }

  producer_pulsar_message {
    desc = "Template to render a Pulsar message."
    label = "Pulsar Message Template"
  }

  producer_pulsar_topic {
    desc = "Pulsar topic name"
    label = "Pulsar topic name"
  }

  producer_retention_period {
    desc = "The amount of time messages will be buffered while there is no connection to"
           " the Pulsar broker.  Longer times mean that more memory/disk will be used"
    label = "Retention Period"
  }

  producer_send_buffer {
    desc = "Fine tune the socket send buffer. The default value is tuned for high throughput."
    label = "Socket Send Buffer Size"
  }

  producer_strategy {
    desc = "Partition strategy is to tell the producer how to dispatch messages to Pulsar partitions.\n"
           "\n"
           "<code>random</code>: Randomly pick a partition for each message.\n"
           "<code>roundrobin</code>: Pick each available producer in turn for each message.\n"
           "<code>key_dispatch</code>: Hash Pulsar message key of the first message in a batch"
           " to a partition number."
    label = "Partition Strategy"
  }

  producer_sync_timeout {
    desc = "Maximum wait time for receiving a receipt from Pulsar when publishing synchronously."
    label = "Sync publish timeout"
  }

  producer_value_template {
    desc = "Template to render Pulsar message value."
    label = "Message Value"
  }

  pulsar_producer_struct {
    desc = "Configuration for a Pulsar bridge."
    label = "Pulsar Bridge Configuration"
  }

  servers {
    desc = "A comma separated list of Pulsar URLs in the form <code>scheme://host[:port]</code>"
           " for the client to connect to. The supported schemes are <code>pulsar://</code> (default)"
           " and <code>pulsar+ssl://</code>. The default port is 6650."
    label = "Servers"
  }
}

emqx_bridge_rabbitmq {

    local_topic.desc:
    """The MQTT topic filter to be forwarded to RabbitMQ. All MQTT 'PUBLISH' messages with the topic matching the local_topic will be forwarded.
    NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is configured, then both the data got from the rule and the MQTT messages that match local_topic will be forwarded."""

    local_topic.label:
    """Local Topic"""

    config_enable.desc:
    """Enable or disable this bridge"""

    config_enable.label:
    """Enable or Disable Bridge"""

    desc_config.desc:
    """Configuration for a RabbitMQ bridge."""

    desc_config.label:
    """RabbitMQ Bridge Configuration"""

    desc_type.desc:
    """The Bridge Type"""

    desc_type.label:
    """Bridge Type"""

    desc_name.desc:
    """Bridge name."""

    desc_name.label:
    """Bridge Name"""

}


emqx_bridge_rabbitmq_connector {

server.desc:
"""The RabbitMQ server address that you want to connect to (for example, localhost)."""

server.label:
"""Server"""

port.desc:
"""The port number on which the RabbitMQ server is listening (default is 5672)."""

port.label:
"""Port"""

username.desc:
"""The username used to authenticate with the RabbitMQ server."""

username.label:
"""Username"""

password.desc:
"""The password used to authenticate with the RabbitMQ server."""

password.label:
"""Password"""

pool_size.desc:
"""The size of the connection pool."""

pool_size.label:
"""Pool Size"""

timeout.desc:
"""The timeout for waiting on the connection to be established."""

timeout.label:
"""Connection Timeout"""

virtual_host.desc:
"""The virtual host to use when connecting to the RabbitMQ server."""

virtual_host.label:
"""Virtual Host"""

heartbeat.desc:
"""The interval for sending heartbeat messages to the RabbitMQ server."""

heartbeat.label:
"""Heartbeat"""

auto_reconnect.desc:
"""The interval for attempting to reconnect to the RabbitMQ server if the connection is lost."""

auto_reconnect.label:
"""Auto Reconnect"""

exchange.desc:
"""The name of the RabbitMQ exchange where the messages will be sent."""

exchange.label:
"""Exchange"""

exchange_type.desc:
"""The type of the RabbitMQ exchange (direct, fanout, or topic)."""

exchange_type.label:
"""Exchange Type"""

routing_key.desc:
"""The routing key used to route messages to the correct queue in the RabbitMQ exchange."""

routing_key.label:
"""Routing Key"""

delivery_mode.desc:
"""The delivery mode for messages published to RabbitMQ. Delivery mode non_persistent (1) is suitable for messages that don't require persistence across RabbitMQ restarts, whereas delivery mode persistent (2) is designed for messages that must survive RabbitMQ restarts."""

delivery_mode.label:
"""Message Delivery Mode"""

payload_template.desc:
"""The template for formatting the payload of the message before sending it to RabbitMQ. Template placeholders, such as ${field1.sub_field}, will be substituted with the respective field's value. When left empty, the entire input message will be used as the payload, formatted as a JSON text. This behavior is equivalent to specifying ${.} as the payload template."""

payload_template.label:
"""Payload Template"""

publish_confirmation_timeout.desc:
"""The timeout for waiting for RabbitMQ to confirm message publication when using publisher confirms."""

publish_confirmation_timeout.label:
"""Publish Confirmation Timeout"""

wait_for_publish_confirmations.desc:
"""A boolean value that indicates whether to wait for RabbitMQ to confirm message publication when using publisher confirms."""

wait_for_publish_confirmations.label:
"""Wait for Publish Confirmations"""

}

emqx_bridge_redis {

command_template.desc:
"""Redis command template used to export messages. Each list element stands for a command name or its argument.
For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:
`rpush`, `msgs`, `${payload}`."""

command_template.label:
"""Redis Command Template"""

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a Redis bridge."""

desc_config.label:
"""Redis Bridge Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

}

emqx_bridge_rocketmq {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a RocketMQ bridge."""

desc_config.label:
"""RocketMQ Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic
matching the `local_topic` will be forwarded.</br>
NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."""

local_topic.label:
"""Local Topic"""

template.desc:
"""Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br>
            The template can be any valid string with placeholders, example:<br>
            - ${id}, ${username}, ${clientid}, ${timestamp}<br>
            - {"id" : ${id}, "username" : ${username}}"""

template.label:
"""Template"""

}

emqx_bridge_rocketmq_connector {

access_key.desc:
"""RocketMQ server `accessKey`."""

access_key.label:
"""AccessKey"""

refresh_interval.desc:
"""RocketMQ Topic Route Refresh Interval."""

refresh_interval.label:
"""Topic Route Refresh Interval"""

secret_key.desc:
"""RocketMQ server `secretKey`."""

secret_key.label:
"""SecretKey"""

security_token.desc:
"""RocketMQ Server Security Token"""

security_token.label:
"""Security Token"""

send_buffer.desc:
"""The socket send buffer size of the RocketMQ driver client."""

send_buffer.label:
"""Send Buffer Size"""

servers.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The RocketMQ default port 9876 is used if `[:Port]` is not specified."""

servers.label:
"""Server Host"""

sync_timeout.desc:
"""Timeout of RocketMQ driver synchronous call."""

sync_timeout.label:
"""Sync Timeout"""

topic.desc:
"""RocketMQ Topic"""

topic.label:
"""RocketMQ Topic"""

}

emqx_bridge_schema {

bridges_mqtt.desc:
"""MQTT bridges to/from another MQTT broker"""

bridges_mqtt.label:
"""MQTT Bridge"""

bridges_webhook.desc:
"""WebHook to an HTTP server."""

bridges_webhook.label:
"""WebHook"""

desc_bridges.desc:
"""Configuration for MQTT bridges."""

desc_bridges.label:
"""MQTT Bridge Configuration"""

desc_enable.desc:
"""Enable or disable this bridge"""

desc_enable.label:
"""Enable Or Disable Bridge"""

desc_metrics.desc:
"""Bridge metrics."""

desc_metrics.label:
"""Bridge Metrics"""

desc_node_metrics.desc:
"""Node metrics."""

desc_node_metrics.label:
"""Node Metrics"""

desc_node_name.desc:
"""The node name."""

desc_node_name.label:
"""Node Name"""

desc_node_status.desc:
"""Node status."""

desc_node_status.label:
"""Node Status"""

desc_status.desc:
"""The status of the bridge<br/>
- <code>connecting</code>: the initial state before any health probes were made.<br/>
- <code>connected</code>: when the bridge passes the health probes.<br/>
- <code>disconnected</code>: when the bridge can not pass health probes.<br/>
- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/>
- <code>inconsistent</code>: When not all the nodes are at the same status."""

desc_status.label:
"""Bridge Status"""

desc_status_reason.desc:
"""This is the reason given in case a bridge is failing to connect."""

desc_status_reason.label:
"""Failure reason"""

metric_dropped.desc:
"""Count of messages dropped."""

metric_dropped.label:
"""Dropped"""

metric_dropped_other.desc:
"""Count of messages dropped due to other reasons."""

metric_dropped_other.label:
"""Dropped Other"""

metric_dropped_queue_full.desc:
"""Count of messages dropped due to the queue is full."""

metric_dropped_queue_full.label:
"""Dropped Queue Full"""

metric_dropped_resource_not_found.desc:
"""Count of messages dropped due to the resource is not found."""

metric_dropped_resource_not_found.label:
"""Dropped Resource NotFound"""

metric_dropped_resource_stopped.desc:
"""Count of messages dropped due to the resource is stopped."""

metric_dropped_resource_stopped.label:
"""Dropped Resource Stopped"""

metric_inflight.desc:
"""Count of messages that were sent asynchronously but ACKs are not yet received."""

metric_inflight.label:
"""Sent Inflight"""

metric_matched.desc:
"""Count of this bridge is matched and queried."""

metric_matched.label:
"""Matched"""

metric_queuing.desc:
"""Count of messages that are currently queuing."""

metric_queuing.label:
"""Queued"""

metric_rate.desc:
"""The rate of matched, times/second"""

metric_rate.label:
"""Rate"""

metric_rate_last5m.desc:
"""The average rate of matched in the last 5 minutes, times/second"""

metric_rate_last5m.label:
"""Last 5 Minutes Rate"""

metric_rate_max.desc:
"""The max rate of matched, times/second"""

metric_rate_max.label:
"""Max Rate Of Matched"""

metric_received.desc:
"""Count of messages that is received from the remote system."""

metric_received.label:
"""Received"""

metric_retried.desc:
"""Times of retried."""

metric_retried.label:
"""Retried"""

metric_sent_failed.desc:
"""Count of messages that sent failed."""

metric_sent_failed.label:
"""Sent Failed"""

metric_sent_success.desc:
"""Count of messages that sent successfully."""

metric_sent_success.label:
"""Sent Success"""

}

emqx_bridge_sqlserver {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a Microsoft SQL Server bridge."""

desc_config.label:
"""Microsoft SQL Server Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

driver.desc:
"""SQL Server Driver Name"""

driver.label:
"""SQL Server Driver Name"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

sql_template.desc:
"""SQL Template"""

sql_template.label:
"""SQL Template"""

}

emqx_bridge_sqlserver_connector {

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The SQL Server default port 1433 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

}

emqx_bridge_tdengine {

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for a TDengine bridge."""

desc_config.label:
"""TDengine Bridge Configuration"""

desc_name.desc:
"""Bridge name."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

sql_template.desc:
"""SQL Template"""

sql_template.label:
"""SQL Template"""

}

emqx_bridge_tdengine_connector {

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The TDengine default port 6041 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

}

emqx_bridge_webhook_schema {

config_body.desc:
"""The body of the HTTP request.<br/>
If not provided, the body will be a JSON object of all the available fields.<br/>
There, 'all the available fields' means the context of a MQTT message when
this webhook is triggered by receiving a MQTT message (the `local_topic` is set),
or the context of the event when this webhook is triggered by a rule (i.e. this
webhook is used as an action of a rule).<br/>
Template with variables is allowed."""

config_body.label:
"""HTTP Body"""

config_direction.desc:
"""Deprecated, The direction of this bridge, MUST be 'egress'"""

config_direction.label:
"""Bridge Direction"""

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

config_headers.desc:
"""The headers of the HTTP request.<br/>
Template with variables is allowed."""

config_headers.label:
"""HTTP Header"""

config_local_topic.desc:
"""The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.<br/>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

config_local_topic.label:
"""Local Topic"""

config_max_retries.desc:
"""HTTP request max retry times if failed."""

config_max_retries.label:
"""HTTP Request Max Retries"""

config_method.desc:
"""The method of the HTTP request. All the available methods are: post, put, get, delete.<br/>
Template with variables is allowed."""

config_method.label:
"""HTTP Method"""

config_request_timeout.desc:
"""HTTP request timeout."""

config_request_timeout.label:
"""HTTP Request Timeout"""

config_url.desc:
"""The URL of the HTTP Bridge.<br/>
Template with variables is allowed in the path, but variables cannot be used in the scheme, host,
or port part.<br/>
For example, <code> http://localhost:9901/${topic} </code> is allowed, but
<code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code>
is not allowed."""

config_url.label:
"""HTTP Bridge"""

desc_config.desc:
"""Configuration for an HTTP bridge."""

desc_config.label:
"""HTTP Bridge Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

}

emqx_coap_api {

content_type.desc:
"""Payload type"""

message_id.desc:
"""Message ID"""

method.desc:
"""Request method type"""

payload.desc:
"""The content of the payload"""

response_code.desc:
"""Response code"""

send_coap_request.desc:
"""Send a CoAP request message to the client"""

timeout.desc:
"""Timespan for response"""

token.desc:
"""Message token, can be empty"""

}

emqx_coap_schema {

coap.desc:
"""The CoAP Gateway configuration.
This gateway is implemented based on RFC-7252 and https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"""

coap_connection_required.desc:
"""Enable or disable connection mode.
Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources"""

coap_heartbeat.desc:
"""The gateway server required minimum heartbeat interval.
When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive"""

coap_notify_type.desc:
"""The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.
The type of delivered coap message can be set to:<br/>
  - non: Non-confirmable;<br/>
  - con: Confirmable;<br/>
  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con"""

coap_publish_qos.desc:
"""The Default QoS Level indicator for publish request.
This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:<br/>
  - qos0, qos1, qos2: Fixed default QoS level<br/>
  - coap: Dynamic QoS level by the message type of publish request<br/>
    * qos0: If the publish request is non-confirmable<br/>
    * qos1: If the publish request is confirmable"""

coap_subscribe_qos.desc:
"""The Default QoS Level indicator for subscribe request.
This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:<br/>
  - qos0, qos1, qos2: Fixed default QoS level<br/>
  - coap: Dynamic QoS level by the message type of subscribe request<br/>
    * qos0: If the subscribe request is non-confirmable<br/>
    * qos1: If the subscribe request is confirmable"""

}

emqx_conf_schema {

common_handler_drop_mode_qlen.desc:
"""When the number of buffered log events is larger than this value, the new log events are dropped.
When drop mode is activated or deactivated, a message is printed in the logs."""

common_handler_drop_mode_qlen.label:
"""Queue Length before Entering Drop Mode"""

cluster_mcast_addr.desc:
"""Multicast IPv4 address."""

cluster_mcast_addr.label:
"""Cluster Multicast Address"""

desc_cluster_dns.desc:
"""Service discovery via DNS SRV records."""

desc_cluster_dns.label:
"""Cluster DNS"""

cluster_dns_name.desc:
"""The domain name from which to discover peer EMQX nodes' IP addresses.
Applicable when <code>cluster.discovery_strategy = dns</code>"""

cluster_dns_name.label:
"""Cluster Dns Name"""

rpc_keyfile.desc:
"""Path to the private key file for the <code>rpc.certfile</code>.<br/>
Note: contents of this file are secret, so it's necessary to set permissions to 600."""

rpc_keyfile.label:
"""RPC Keyfile"""

cluster_mcast_recbuf.desc:
"""Size of the kernel-level buffer for incoming datagrams."""

cluster_mcast_recbuf.label:
"""Cluster Muticast Sendbuf"""

cluster_autoheal.desc:
"""If <code>true</code>, the node will try to heal network partitions automatically."""

cluster_autoheal.label:
"""Cluster Auto Heal"""

log_overload_kill_enable.desc:
"""Enable log handler overload kill feature."""

log_overload_kill_enable.label:
"""Log Handler Overload Kill"""

node_etc_dir.desc:
"""<code>etc</code> dir for the node"""

node_etc_dir.label:
"""Etc Dir"""

cluster_proto_dist.desc:
"""The Erlang distribution protocol for the cluster.<br/>
- inet_tcp: IPv4 TCP <br/>
- inet_tls: IPv4 TLS, works together with <code>etc/ssl_dist.conf</code>"""

cluster_proto_dist.label:
"""Cluster Protocol Distribution"""

log_burst_limit_enable.desc:
"""Enable log burst control feature."""

log_burst_limit_enable.label:
"""Enable Burst"""

dist_buffer_size.desc:
"""Erlang's distribution buffer busy limit in kilobytes."""

dist_buffer_size.label:
"""Erlang's dist buffer size(KB)"""

common_handler_max_depth.desc:
"""Maximum depth for Erlang term log formatting and Erlang process message queue inspection."""

common_handler_max_depth.label:
"""Max Depth"""

desc_log.desc:
"""EMQX supports multiple log handlers, one console handler and multiple file handlers.
EMQX by default logs to console when running in docker or in console/foreground mode,
otherwise it logs to file $EMQX_LOG_DIR/emqx.log.
For advanced configuration, you can find more parameters in this section."""

desc_log.label:
"""Log"""

common_handler_flush_qlen.desc:
"""If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.
To flush events, the handler discards the buffered log messages without logging."""

common_handler_flush_qlen.label:
"""Flush Threshold"""

common_handler_chars_limit.desc:
"""Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.
NOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended."""

common_handler_chars_limit.label:
"""Single Log Max Length"""

cluster_k8s_namespace.desc:
"""Kubernetes namespace."""

cluster_k8s_namespace.label:
"""K8s Namespace"""

node_name.desc:
"""Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or
<code>%name%@IPv4</code> format."""

node_name.label:
"""Node Name"""

rpc_port_discovery.desc:
"""<code>manual</code>: discover ports by <code>tcp_server_port</code>.<br/>
<code>stateless</code>: discover ports in a stateless manner, using the following algorithm.
If node name is <code>emqxN@127.0.0.1</code>, where the N is an integer,
then the listening port will be 5370 + N."""

rpc_port_discovery.label:
"""RRC Port Discovery"""

log_overload_kill_restart_after.desc:
"""The handler restarts automatically after a delay in the event of termination, unless the value `infinity` is set, which blocks any subsequent restarts."""

log_overload_kill_restart_after.label:
"""Handler Restart Timer"""

log_file_handler_max_size.desc:
"""This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `rotation_size` in bytes."""

log_file_handler_max_size.label:
"""Rotation Size"""

desc_log_file_handler.desc:
"""Log handler that prints log events to files."""

desc_log_file_handler.label:
"""Files Log Handler"""

rpc_socket_keepalive_count.desc:
"""How many times the keepalive probe message can fail to receive a reply
until the RPC connection is considered lost."""

rpc_socket_keepalive_count.label:
"""RPC Socket Keepalive Count"""

cluster_etcd_server.desc:
"""List of endpoint URLs of the etcd cluster"""

cluster_etcd_server.label:
"""Cluster Etcd Server"""

db_backend.desc:
"""Select the backend for the embedded database.<br/>
<code>rlog</code> is the default backend,
that is suitable for very large clusters.<br/>
<code>mnesia</code> is a backend that offers decent performance in small clusters."""

db_backend.label:
"""DB Backend"""

desc_authorization.desc:
"""Settings that control client authorization."""

desc_authorization.label:
"""Authorization"""

cluster_etcd_ssl.desc:
"""Options for the TLS connection to the etcd cluster."""

cluster_etcd_ssl.label:
"""Cluster Etcd SSL Option"""

rpc_insecure_fallback.desc:
"""Enable compatibility with old RPC authentication."""

rpc_insecure_fallback.label:
"""RPC insecure fallback"""

cluster_mcast_buffer.desc:
"""Size of the user-level buffer."""

cluster_mcast_buffer.label:
"""Cluster Muticast Buffer"""

rpc_authentication_timeout.desc:
"""Timeout for the remote node authentication."""

rpc_authentication_timeout.label:
"""RPC Authentication Timeout"""

cluster_call_retry_interval.desc:
"""Time interval to retry after a failed call."""

cluster_call_retry_interval.label:
"""Cluster Call Retry Interval"""

cluster_mcast_sndbuf.desc:
"""Size of the kernel-level buffer for outgoing datagrams."""

cluster_mcast_sndbuf.label:
"""Cluster Muticast Sendbuf"""

rpc_driver.desc:
"""Transport protocol used for inter-broker communication"""

rpc_driver.label:
"""RPC dirver"""

max_ets_tables.desc:
"""Max number of ETS tables"""

max_ets_tables.label:
"""Max number of ETS tables"""

desc_db.desc:
"""Settings for the embedded database."""

desc_db.label:
"""Database"""

desc_cluster_etcd.desc:
"""Service discovery using 'etcd' service."""

desc_cluster_etcd.label:
"""Cluster Etcd"""

cluster_name.desc:
"""Human-friendly name of the EMQX cluster."""

cluster_name.label:
"""Cluster Name"""

log_rotation_enable.desc:
"""Enable log rotation feature."""

log_rotation_enable.label:
"""Rotation Enable"""

cluster_call_cleanup_interval.desc:
"""Time interval to clear completed but stale transactions.
Ensure that the number of completed transactions is less than the <code>max_history</code>."""

cluster_call_cleanup_interval.label:
"""Clean Up Interval"""

desc_cluster_static.desc:
"""Service discovery via static nodes.
The new node joins the cluster by connecting to one of the bootstrap nodes."""

desc_cluster_static.label:
"""Cluster Static"""

db_default_shard_transport.desc:
"""Defines the default transport for pushing transaction logs.<br/>
This may be overridden on a per-shard basis in <code>db.shard_transports</code>.
<code>gen_rpc</code> uses the <code>gen_rpc</code> library,
<code>distr</code> uses the Erlang distribution."""

db_default_shard_transport.label:
"""Default Shard Transport"""

cluster_static_seeds.desc:
"""List EMQX node names in the static cluster. See <code>node.name</code>."""

cluster_static_seeds.label:
"""Cluster Static Seeds"""

log_overload_kill_qlen.desc:
"""Maximum allowed queue length."""

log_overload_kill_qlen.label:
"""Max Queue Length"""

node_backtrace_depth.desc:
"""Maximum depth of the call stack printed in error messages and
<code>process_info</code>."""

node_backtrace_depth.label:
"""BackTrace Depth"""

desc_log_burst_limit.desc:
"""Large bursts of log events produced in a short time can potentially cause problems, such as:
 - Log files grow very large
 - Log files are rotated too quickly, and useful information gets overwritten
 - Overall performance impact on the system

Log burst limit feature can temporarily disable logging to avoid these issues."""

desc_log_burst_limit.label:
"""Log Burst Limit"""

common_handler_enable.desc:
"""Enable this log handler."""

common_handler_enable.label:
"""Enable Log Handler"""

cluster_k8s_service_name.desc:
"""EMQX broker service name."""

cluster_k8s_service_name.label:
"""K8s Service Name"""

log_rotation_count.desc:
"""Maximum number of log files."""

log_rotation_count.label:
"""Max Log Files Number"""

node_cookie.desc:
"""Secret cookie is a random string that should be the same on all nodes in
the given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that
belong to different clusters from accidentally connecting to each other."""

node_cookie.label:
"""Node Cookie"""

db_role.desc:
"""Select a node role.<br/>
<code>core</code> nodes provide durability of the data, and take care of writes.
It is recommended to place core nodes in different racks or different availability zones.<br/>
<code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster
doesn't affect database redundancy<br/>
It is recommended to have more replicant nodes than core nodes.<br/>
Note: this parameter only takes effect when the <code>backend</code> is set
to <code>rlog</code>."""

db_role.label:
"""DB Role"""

rpc_tcp_server_port.desc:
"""Listening port used by RPC local service.<br/>
Note that this config only takes effect when rpc.port_discovery is set to manual."""

rpc_tcp_server_port.label:
"""RPC TCP Server Port"""

desc_console_handler.desc:
"""Log handler that prints log events to the EMQX console."""

desc_console_handler.label:
"""Console Handler"""

node_applications.desc:
"""List of Erlang applications that shall be rebooted when the EMQX broker joins the cluster."""

node_applications.label:
"""Application"""

log_burst_limit_max_count.desc:
"""Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`."""

log_burst_limit_max_count.label:
"""Events Number"""

rpc_tcp_client_num.desc:
"""Set the maximum number of RPC communication channels initiated by this node to each remote node."""

rpc_tcp_client_num.label:
"""RPC TCP Client Num"""

cluster_k8s_address_type.desc:
"""Address type used for connecting to the discovered nodes.
Setting <code>cluster.k8s.address_type</code> to <code>ip</code> will
make EMQX to discover IP addresses of peer nodes from Kubernetes API."""

cluster_k8s_address_type.label:
"""K8s Address Type"""

rpc_socket_sndbuf.desc:
"""TCP tuning parameters. TCP sending buffer size."""

rpc_socket_sndbuf.label:
"""RPC Socket Sndbuf"""

cluster_mcast_ttl.desc:
"""Time-to-live (TTL) for the outgoing UDP datagrams."""

cluster_mcast_ttl.label:
"""Cluster Multicast TTL"""

log_file_handler_file.desc:
"""Name the log file."""

log_file_handler_file.label:
"""Log File Name"""

node_dist_net_ticktime.desc:
"""This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected."""

node_dist_net_ticktime.label:
"""Dist Net TickTime"""

desc_cluster_k8s.desc:
"""Service discovery via Kubernetes API server."""

desc_cluster_k8s.label:
"""Cluster Kubernetes"""

desc_cluster_mcast.desc:
"""Service discovery via UDP multicast."""

desc_cluster_mcast.label:
"""Cluster Multicast"""

rpc_cacertfile.desc:
"""Path to certification authority TLS certificate file used to validate <code>rpc.certfile</code>.<br/>
Note: certificates of all nodes in the cluster must be signed by the same CA."""

rpc_cacertfile.label:
"""RPC Cacertfile"""

desc_node.desc:
"""Node name, cookie, config & data directories and the Erlang virtual machine (BEAM) boot parameters."""

desc_node.label:
"""Node"""

cluster_k8s_apiserver.desc:
"""Kubernetes API endpoint URL."""

cluster_k8s_apiserver.label:
"""Cluster k8s ApiServer"""

common_handler_supervisor_reports.desc:
"""Type of supervisor reports that are logged. Defaults to <code>error</code><br/>
  - <code>error</code>: only log errors in the Erlang processes<br/>.
  - <code>progress</code>: log process startup."""

common_handler_supervisor_reports.label:
"""Report Type"""

node_data_dir.desc:
"""Path to the persistent data directory.<br/>
Possible auto-created subdirectories are:<br/>
- `mnesia/<node_name>`: EMQX's built-in database directory.<br/>
For example, `mnesia/emqx@127.0.0.1`.<br/>
There should be only one such subdirectory.<br/>
Meaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),<br/>
the old dir should be deleted first.<br/>
- `configs`: Generated configs at boot time, and cluster/local override configs.<br/>
- `patches`: Hot-patch beam files are to be placed here.<br/>
- `trace`: Trace log files.<br/>

**NOTE**: One data dir cannot be shared by two or more EMQX nodes."""

node_data_dir.label:
"""Node Data Dir"""

cluster_k8s_suffix.desc:
"""Node name suffix.<br/>
Note: this parameter is only relevant when <code>address_type</code> is <code>dns</code>
or <code>hostname</code>."""

cluster_k8s_suffix.label:
"""K8s Suffix"""

db_rpc_module.desc:
"""Protocol used for pushing transaction logs to the replicant nodes."""

db_rpc_module.label:
"""RPC Module"""

cluster_etcd_prefix.desc:
"""Key prefix used for EMQX service discovery."""

cluster_etcd_prefix.label:
"""Cluster Etcd Prefix"""

cluster_mcast_iface.desc:
"""Local IP address the node discovery service needs to bind to."""

cluster_mcast_iface.label:
"""Cluster Multicast Interface"""

log_burst_limit_window_time.desc:
"""See <code>max_count</code>."""

log_burst_limit_window_time.label:
"""Window Time"""

cluster_dns_record_type.desc:
"""DNS record type."""

cluster_dns_record_type.label:
"""DNS Record Type"""

cluster_autoclean.desc:
"""Remove disconnected nodes from the cluster after this interval."""

cluster_autoclean.label:
"""Cluster Auto Clean"""

process_limit.desc:
"""Maximum number of simultaneously existing processes for this Erlang system.
For more information, see: https://www.erlang.org/doc/man/erl.html"""

process_limit.label:
"""Erlang Process Limit"""

max_ports.desc:
"""Maximum number of simultaneously open files and sockets for this Erlang system.
For more information, see: https://www.erlang.org/doc/man/erl.html"""

max_ports.label:
"""Erlang Port Limit"""

desc_log_rotation.desc:
"""By default, the logs are stored in `./log` directory (for installation from zip file) or in `/var/log/emqx` (for binary installation).<br/>
This section of the configuration controls the number of files kept for each log handler."""

desc_log_rotation.label:
"""Log Rotation"""

desc_log_overload_kill.desc:
"""Log overload kill features an overload protection that activates when the log handlers use too much memory or have too many buffered log messages.<br/>
When the overload is detected, the log handler is terminated and restarted after a cooldown period."""

desc_log_overload_kill.label:
"""Log Overload Kill"""

authorization.desc:
"""Authorization a.k.a. ACL.<br/>
In EMQX, MQTT client access control is extremely flexible.<br/>
An out-of-the-box set of authorization data sources are supported.
For example,<br/>
'file' source is to support concise and yet generic ACL rules in a file;<br/>
'built_in_database' source can be used to store per-client customizable rule sets,
natively in the EMQX node;<br/>
'http' source to make EMQX call an external HTTP API to make the decision;<br/>
'PostgreSQL' etc. to look up clients or rules from external databases"""

authorization.label:
"""Authorization"""

rpc_socket_keepalive_idle.desc:
"""How long the connections between the brokers should remain open after the last message is sent."""

rpc_socket_keepalive_idle.label:
"""RPC Socket Keepalive Idle"""

desc_cluster_call.desc:
"""Options for the 'cluster call' feature that allows to execute a callback on all nodes in the cluster."""

desc_cluster_call.label:
"""Cluster Call"""

cluster_mcast_ports.desc:
"""List of UDP ports used for service discovery.<br/>
Note: probe messages are broadcast to all the specified ports."""

cluster_mcast_ports.label:
"""Cluster Multicast Ports"""

log_overload_kill_mem_size.desc:
"""Maximum memory size that the log handler process is allowed to use."""

log_overload_kill_mem_size.label:
"""Log Handler Max Memory Size"""

rpc_connect_timeout.desc:
"""Timeout for establishing an RPC connection."""

rpc_connect_timeout.label:
"""RPC Connect Timeout"""

cluster_etcd_node_ttl.desc:
"""Expiration time of the etcd key associated with the node.
It is refreshed automatically, as long as the node is alive."""

cluster_etcd_node_ttl.label:
"""Cluster Etcd Node TTL"""

rpc_call_receive_timeout.desc:
"""Timeout for the reply to a synchronous RPC."""

rpc_call_receive_timeout.label:
"""RPC Call Receive Timeout"""

rpc_socket_recbuf.desc:
"""TCP tuning parameters. TCP receiving buffer size."""

rpc_socket_recbuf.label:
"""RPC Socket Recbuf"""

db_tlog_push_mode.desc:
"""In sync mode the core node waits for an ack from the replicant nodes before sending the next
transaction log entry."""

db_tlog_push_mode.label:
"""Tlog Push Mode"""

node_crash_dump_bytes.desc:
"""This variable sets the maximum size of a crash dump file in bytes.
The crash dump will be truncated if this limit is exceeded.
If setting it to 0, the runtime system does not even attempt to write a crash dump file."""

node_crash_dump_bytes.label:
"""Crash Dump Bytes"""

rpc_certfile.desc:
"""Path to TLS certificate file used to validate identity of the cluster nodes.
Note that this config only takes effect when <code>rpc.driver</code> is set to <code>ssl</code>."""

rpc_certfile.label:
"""RPC Certfile"""

node_crash_dump_seconds.desc:
"""This variable gives the number of seconds that the emulator is allowed to spend writing a crash dump. When the given number of seconds have elapsed, the emulator is terminated.<br/>
- If setting to 0 seconds, the runtime system does not even attempt to write the crash dump file. It only terminates.<br/>
- If setting to a positive value S, wait for S seconds to complete the crash dump file and then terminates the runtime system with a SIGALRM signal.<br/>
- A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completely written."""

node_crash_dump_seconds.label:
"""Crash Dump Seconds"""

log_file_handlers.desc:
"""File-based log handlers."""

log_file_handlers.label:
"""File Handler"""

node_global_gc_interval.desc:
"""Periodic garbage collection interval. Set to <code>disabled</code> to have it disabled."""

node_global_gc_interval.label:
"""Global GC Interval"""

common_handler_time_offset.desc:
"""The time offset to be used when formatting the timestamp.
Can be one of:
  - <code>system</code>: the time offset used by the local system
  - <code>utc</code>: the UTC time offset
  - <code>+-[hh]:[mm]</code>: user specified time offset, such as "-02:00" or "+00:00"
Defaults to: <code>system</code>."""

common_handler_time_offset.label:
"""Time Offset"""

rpc_mode.desc:
"""In <code>sync</code> mode the sending side waits for the ack from the receiving side."""

rpc_mode.label:
"""RPC Mode"""

node_crash_dump_file.desc:
"""Location of the crash dump file."""

node_crash_dump_file.label:
"""Crash Dump File"""

cluster_mcast_loop.desc:
"""If <code>true</code>, loop UDP datagrams back to the local socket."""

cluster_mcast_loop.label:
"""Cluster Multicast Loop"""

rpc_socket_keepalive_interval.desc:
"""The interval between keepalive messages."""

rpc_socket_keepalive_interval.label:
"""RPC Socket Keepalive Interval"""

common_handler_level.desc:
"""The log level for the current log handler.
Defaults to warning."""

common_handler_level.label:
"""Log Level"""

desc_rpc.desc:
"""EMQX uses a library called <code>gen_rpc</code> for inter-broker communication.<br/>
Most of the time the default config should work,
but in case you need to do performance fine-tuning or experiment a bit,
this is where to look."""

desc_rpc.label:
"""RPC"""

rpc_ssl_server_port.desc:
"""Listening port used by RPC local service.<br/>
Note that this config only takes effect when rpc.port_discovery is set to manual
and <code>driver</code> is set to <code>ssl</code>."""

rpc_ssl_server_port.label:
"""RPC SSL Server Port"""

desc_cluster.desc:
"""EMQX nodes can form a cluster to scale up the total capacity.<br/>
      Here holds the configs to instruct how individual nodes can discover each other."""

desc_cluster.label:
"""Cluster"""

common_handler_sync_mode_qlen.desc:
"""As long as the number of buffered log events is lower than this value,
all log events are handled asynchronously. This means that the client process sending the log event,
by calling a log function in the Logger API, does not wait for a response from the handler
but continues executing immediately after the event is sent.
It is not affected by the time it takes the handler to print the event to the log device.
If the message queue grows larger than this value,
the handler starts handling log events synchronously instead,
meaning that the client process sending the event must wait for a response.
When the handler reduces the message queue to a level below the sync_mode_qlen threshold,
asynchronous operation is resumed."""

common_handler_sync_mode_qlen.label:
"""Queue Length before Entering Sync Mode"""

common_handler_formatter.desc:
"""Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging."""

common_handler_formatter.label:
"""Log Formatter"""

rpc_async_batch_size.desc:
"""The maximum number of batch messages sent in asynchronous mode.
      Note that this configuration does not work in synchronous mode."""

rpc_async_batch_size.label:
"""Async Batch Size"""

cluster_call_max_history.desc:
"""Retain the maximum number of completed transactions (for queries)."""

cluster_call_max_history.label:
"""Cluster Call Max History"""

cluster_discovery_strategy.desc:
"""Service discovery method for the cluster nodes. Possible values are:
- manual: Use <code>emqx ctl cluster</code> command to manage cluster.<br/>
- static: Configure static nodes list by setting <code>seeds</code> in config file.<br/>
- dns: Use DNS A record to discover peer nodes.<br/>
- etcd: Use etcd to discover peer nodes.<br/>
- k8s: Use Kubernetes API to discover peer pods.
- mcast: Deprecated since 5.1, will be removed in 5.2.
  This supports discovery via UDP multicast."""

cluster_discovery_strategy.label:
"""Cluster Discovery Strategy"""

rpc_send_timeout.desc:
"""Timeout for sending the RPC request."""

rpc_send_timeout.label:
"""RPC Send Timeout"""

common_handler_single_line.desc:
"""Print logs in a single line if set to true. Otherwise, log messages may span multiple lines."""

common_handler_single_line.label:
"""Single Line Mode"""

rpc_socket_buffer.desc:
"""TCP tuning parameters. Socket buffer size in user mode."""

rpc_socket_buffer.label:
"""RPC Socket Buffer"""

db_shard_transports.desc:
"""Allows to tune the transport method used for transaction log replication, on a per-shard basis.<br/>
<code>gen_rpc</code> uses the <code>gen_rpc</code> library,
<code>distr</code> uses the Erlang distribution.<br/>If not specified,
the default is to use the value set in <code>db.default_shard_transport</code>."""

db_shard_transports.label:
"""Shard Transports"""

}

emqx_connector_http {

body.desc:
"""HTTP request body."""

body.label:
"""HTTP Body"""

connect_timeout.desc:
"""The timeout when connecting to the HTTP server."""

connect_timeout.label:
"""Connect Timeout"""

enable_pipelining.desc:
"""A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request."""

enable_pipelining.label:
"""HTTP Pipelineing"""

headers.desc:
"""List of HTTP headers."""

headers.label:
"""HTTP Headers"""

max_retries.desc:
"""Max retry times if error on sending request."""

max_retries.label:
"""Max Retries"""

method.desc:
"""HTTP method."""

method.label:
"""HTTP Method"""

path.desc:
"""URL path."""

path.label:
"""URL Path"""

pool_size.desc:
"""The pool size."""

pool_size.label:
"""Pool Size"""

pool_type.desc:
"""The type of the pool. Can be one of `random`, `hash`."""

pool_type.label:
"""Pool Type"""

request.desc:
"""Configure HTTP request parameters."""

request.label:
"""Request"""

request_timeout.desc:
"""HTTP request timeout."""

request_timeout.label:
"""Request Timeout"""

}

emqx_connector_ldap {

bind_dn.desc:
"""LDAP's Binding Distinguished Name (DN)"""

bind_dn.label:
"""Bind DN"""

port.desc:
"""LDAP Port"""

port.label:
"""Port"""

timeout.desc:
"""LDAP's query timeout"""

timeout.label:
"""timeout"""

}

emqx_connector_pgsql {

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The PostgreSQL default port 5432 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

}

emqx_connector_schema_lib {

auto_reconnect.desc:
"""Deprecated. Enable automatic reconnect to the database."""

auto_reconnect.label:
"""Deprecated. Auto Reconnect Database"""

database_desc.desc:
"""Database name."""

database_desc.label:
"""Database Name"""

password.desc:
"""The password associated with the bridge, used for authentication with the external database."""

password.label:
"""Password"""

pool_size.desc:
"""Size of the connection pool towards the bridge target service."""

pool_size.label:
"""Connection Pool Size"""

prepare_statement.desc:
"""Key-value list of SQL prepared statements."""

prepare_statement.label:
"""SQL Prepared Statements List"""

ssl.desc:
"""SSL connection settings."""

ssl.label:
"""Enable SSL"""

username.desc:
"""The username associated with the bridge in the external database used for authentication or identification purposes."""

username.label:
"""Username"""

}

emqx_dashboard_api {

change_pwd_api.desc:
"""Change dashboard user password"""
change_pwd_api.label:
"""Change dashboard user password"""

create_user_api.desc:
"""Create dashboard user"""
create_user_api.label:
"""Create dashboard user"""

create_user_api_success.desc:
"""Create dashboard user success"""
create_user_api_success.label:
"""Create dashboard user success"""

delete_user_api.desc:
"""Delete dashboard user"""
delete_user_api.label:
"""Delete dashboard user"""

license.desc:
"""EMQX License. opensource or enterprise"""

list_users_api.desc:
"""Dashboard list users"""
list_users_api.label:
"""Dashboard list users"""

login_api.desc:
"""Get Dashboard Auth Token."""
login_api.label:
"""Get Dashboard Auth Token."""

login_failed401.desc:
"""Login failed. Bad username or password"""

login_failed_response400.desc:
"""Login failed. Bad username or password"""

login_success.desc:
"""Dashboard Auth Success"""

logout_api.desc:
"""Dashboard user logout"""
logout_api.label:
"""Dashboard user logout"""

new_pwd.desc:
"""New password"""

old_pwd.desc:
"""Old password"""

password.desc:
"""Dashboard Password"""

token.desc:
"""Dashboard Auth Token"""

update_user_api.desc:
"""Update dashboard user description"""
update_user_api.label:
"""Update dashboard user description"""

update_user_api200.desc:
"""Update dashboard user success"""

user_description.desc:
"""Dashboard User Description"""

username.desc:
"""Dashboard Username"""

users_api404.desc:
"""Dashboard user not found"""

version.desc:
"""EMQX Version"""

}

emqx_dashboard_error_code_api {

error_codes.desc:
"""API Error Codes"""
error_codes.label:
"""API Error Codes"""

}

emqx_dashboard_monitor_api {

list_monitor.desc:
"""List monitor (statistics) data for the whole cluster."""
list_monitor.label:
"""List cluster stats data"""

list_monitor_node.desc:
"""List the monitor (statistics) data on the specified node."""
list_monitor_node.label:
"""List node's stats data"""

current_stats.desc:
"""Current monitor (statistics) data, e.g. number of connections and connection rate in the whole cluster."""
current_stats.label:
"""Cluster runtime stats"""

current_stats_node.desc:
"""Node monitor (statistics) data, e.g. number of connections and connection rate on the specified node."""
current_stats_node.label:
"""Node runtime stats"""

}

emqx_dashboard_schema {

backlog.desc:
"""Defines the maximum length that the queue of pending connections can grow to."""

backlog.label:
"""Backlog"""

bind.desc:
"""Port without IP(18083) or port with specified IP(127.0.0.1:18083).
Disabled when setting bind to `0`.
"""

bind.label:
"""Bind"""

bootstrap_users_file.desc:
"""Deprecated, use api_key.bootstrap_file."""

bootstrap_users_file.label:
"""Deprecated"""

cors.desc:
"""Support Cross-Origin Resource Sharing (CORS).
Allows a server to indicate any origins (domain, scheme, or port) other than
its own from which a browser should permit loading resources."""

cors.label:
"""CORS"""

default_password.desc:
"""The initial default password for dashboard 'admin' user.
For safety, it should be changed as soon as possible.
This value is not valid when you log in to Dashboard for the first time via the web
and change to a complex password as prompted."""

default_password.label:
"""Default password"""

default_username.desc:
"""The default username of the automatically created dashboard user."""

default_username.label:
"""Default username"""

desc_dashboard.desc:
"""Configuration for EMQX dashboard."""

desc_dashboard.label:
"""Dashboard"""

desc_http.desc:
"""Configuration for the dashboard listener (plaintext)."""

desc_http.label:
"""HTTP"""

desc_https.desc:
"""Configuration for the dashboard listener (TLS)."""

desc_https.label:
"""HTTPS"""

desc_listeners.desc:
"""Configuration for the dashboard listener."""

desc_listeners.label:
"""Listeners"""

i18n_lang.desc:
"""Internationalization language support."""

i18n_lang.label:
"""I18n language"""

inet6.desc:
"""Enable IPv6 support, default is false, which means IPv4 only."""

inet6.label:
"""IPv6"""

ipv6_v6only.desc:
"""Disable IPv4-to-IPv6 mapping for the listener.
The configuration is only valid when the inet6 is true."""

ipv6_v6only.label:
"""IPv6 only"""

listener_enable.desc:
"""Ignore or enable this listener"""

listener_enable.label:
"""Enable"""

listeners.desc:
"""HTTP(s) listeners are identified by their protocol type and are
used to serve dashboard UI and restful HTTP API.
Listeners must have a unique combination of port number and IP address.
For example, an HTTP listener can listen on all configured IP addresses
on a given port for a machine by specifying the IP address 0.0.0.0.
Alternatively, the HTTP listener can specify a unique IP address for each listener,
but use the same port."""

listeners.label:
"""Listeners"""

max_connections.desc:
"""Maximum number of simultaneous connections."""

max_connections.label:
"""Maximum connections"""

num_acceptors.desc:
"""Socket acceptor pool size for TCP protocols. Default is the number of schedulers online"""

num_acceptors.label:
"""Number of acceptors"""

proxy_header.desc:
"""Enable support for `HAProxy` header. Be aware once enabled regular HTTP requests can't be handled anymore."""

proxy_header.label:
"""Enable support for HAProxy header"""

sample_interval.desc:
"""How often to update metrics displayed in the dashboard.
Note: `sample_interval` should be a divisor of 60, default is 10s."""

send_timeout.desc:
"""Send timeout for the socket."""

send_timeout.label:
"""Send timeout"""

token_expired_time.desc:
"""JWT token expiration time. Default is 60 minutes"""

token_expired_time.label:
"""Token expired time"""

ssl_options.desc:
"""SSL/TLS options for the dashboard listener."""

ssl_options.label:
"""SSL options"""

}

emqx_delayed_api {

bad_msgid_format.desc:
"""Bad Message ID format"""
bad_msgid_format.label:
"""Bad Message ID format"""

count.desc:
"""Count of delayed messages"""
count.label:
"""Count of delayed messages"""

delayed_interval.desc:
"""Delayed interval(second)"""
delayed_interval.label:
"""Delayed interval"""

delayed_remaining.desc:
"""Delayed remaining(second)"""
delayed_remaining.label:
"""Delayed remaining"""

delete_api.desc:
"""Delete delayed message"""
delete_api.label:
"""Delete delayed message"""

expected_at.desc:
"""Expect publish time, in RFC 3339 format"""
expected_at.label:
"""Expect publish time"""

from_clientid.desc:
"""From ClientID"""
from_clientid.label:
"""From ClientID"""

from_username.desc:
"""From Username"""
from_username.label:
"""From Username"""

get_message_api.desc:
"""View delayed message"""
get_message_api.label:
"""View delayed message"""

illegality_limit.desc:
"""Max limit illegality"""
illegality_limit.label:
"""Max limit illegality"""

list_api.desc:
"""List delayed messages"""
list_api.label:
"""List delayed messages"""

msgid.desc:
"""Delayed Message ID"""
msgid.label:
"""Delayed Message ID"""

msgid_not_found.desc:
"""Message ID not found"""
msgid_not_found.label:
"""Message ID not found"""

node.desc:
"""The node where message from"""
node.label:
"""Node where message from"""

payload.desc:
"""Payload, base64 encoded. Payload will be set to 'PAYLOAD_TO_LARGE' if its length is larger than 2048 bytes"""
payload.label:
"""Payload"""

publish_at.desc:
"""Clinet publish message time, in RFC 3339 format"""
publish_at.label:
"""Client publish message time"""

qos.desc:
"""QoS"""
qos.label:
"""QoS"""

topic.desc:
"""Topic"""
topic.label:
"""Topic"""

update_api.desc:
"""Enable or disable delayed, set max delayed messages"""
update_api.label:
"""Enable or disable delayed"""

update_success.desc:
"""Enable or disable delayed successfully"""
update_success.label:
"""Enable or disable delayed successfully"""

view_limit.desc:
"""Page limit"""
view_limit.label:
"""Page limit"""

view_page.desc:
"""View page"""
view_page.label:
"""View page"""

view_status_api.desc:
"""Get delayed status"""
view_status_api.label:
"""Get delayed status"""

}

emqx_ee_bridge_hstreamdb {

config_direction.desc:
"""The direction of this bridge, MUST be 'egress'"""

config_direction.label:
"""Bridge Direction"""

config_enable.desc:
"""Enable or disable this bridge"""

config_enable.label:
"""Enable Or Disable Bridge"""

desc_config.desc:
"""Configuration for an HStreamDB bridge."""

desc_config.label:
"""HStreamDB Bridge Configuration"""

desc_connector.desc:
"""Generic configuration for the connector."""

desc_connector.label:
"""Connector Generic Configuration"""

desc_name.desc:
"""Bridge name, used as a human-readable description of the bridge."""

desc_name.label:
"""Bridge Name"""

desc_type.desc:
"""The Bridge Type"""

desc_type.label:
"""Bridge Type"""

local_topic.desc:
"""The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic
matching the local_topic will be forwarded.</br>
NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is
configured, then both the data got from the rule and the MQTT messages that match local_topic
will be forwarded."""

local_topic.label:
"""Local Topic"""

payload.desc:
"""The payload to be forwarded to the HStreamDB. Placeholders supported."""

payload.label:
"""Payload"""

}

emqx_ee_connector_hstreamdb {

config.desc:
"""HStreamDB connection config"""

config.label:
"""Connection config"""

name.desc:
"""Connector name, used as a human-readable description of the connector."""

name.label:
"""Connector Name"""

ordering_key.desc:
"""HStreamDB Ordering Key"""

ordering_key.label:
"""HStreamDB Ordering Key"""

pool_size.desc:
"""HStreamDB Pool Size"""

pool_size.label:
"""HStreamDB Pool Size"""

stream_name.desc:
"""HStreamDB Stream Name"""

stream_name.label:
"""HStreamDB Stream Name"""

type.desc:
"""The Connector Type."""

type.label:
"""Connector Type"""

url.desc:
"""HStreamDB Server URL"""

url.label:
"""HStreamDB Server URL"""

}

emqx_ee_schema_registry_http_api {

desc_param_path_schema_name.desc:
"""The schema name"""

desc_param_path_schema_name.label:
"""Schema name"""

desc_schema_registry_api_delete.desc:
"""Delete a schema"""

desc_schema_registry_api_delete.label:
"""Delete schema"""

desc_schema_registry_api_get.desc:
"""Get a schema by its name"""

desc_schema_registry_api_get.label:
"""Get schema"""

desc_schema_registry_api_list.desc:
"""List all registered schemas"""

desc_schema_registry_api_list.label:
"""List schemas"""

desc_schema_registry_api_post.desc:
"""Register a new schema"""

desc_schema_registry_api_post.label:
"""Register schema"""

desc_schema_registry_api_put.desc:
"""Update an existing schema"""

desc_schema_registry_api_put.label:
"""Update schema"""

}

emqx_ee_schema_registry_schema {

avro_type.desc:
"""[Apache Avro](https://avro.apache.org/) serialization format."""

avro_type.label:
"""Apache Avro"""

protobuf_type.desc:
"""[Protocol Buffers](https://protobuf.dev/) serialization format."""

protobuf_type.label:
"""Protocol Buffers"""

schema_description.desc:
"""A description for this schema."""

schema_description.label:
"""Schema description"""

schema_name.desc:
"""A name for the schema that will serve as its identifier."""

schema_name.label:
"""Schema name"""

schema_registry_root.desc:
"""Schema registry configurations."""

schema_registry_root.label:
"""Schema registry"""

schema_registry_schemas.desc:
"""Registered schemas."""

schema_registry_schemas.label:
"""Registered schemas"""

schema_source.desc:
"""Source text for the schema."""

schema_source.label:
"""Schema source"""

schema_type.desc:
"""Schema type."""

schema_type.label:
"""Schema type"""

}

emqx_eviction_agent_api {

node_eviction_status_get.desc:
"""Get the node eviction status"""

node_eviction_status_get.label:
"""Node Eviction Status"""

}

emqx_exhook_api {

add_server.desc:
"""Add a server"""
add_server.label:
"""Add a server"""

delete_server.desc:
"""Delete the server"""
delete_server.label:
"""Delete the server"""

get_detail.desc:
"""Get the detail information of Exhook server"""
get_detail.label:
"""Get server details"""

get_hooks.desc:
"""Get the hooks information of server"""
get_hooks.label:
"""Get server hooks information"""

hook_metrics.desc:
"""Metrics information of this hook in the current node"""
hook_metrics.label:
"""Hook metrics"""

hook_name.desc:
"""The hook's name"""
hook_name.label:
"""Hook name"""

hook_params.desc:
"""The parameters used when the hook is registered"""
hook_params.label:
"""Hook parameters"""

list_all_servers.desc:
"""List all servers"""
list_all_servers.label:
"""List servers"""

metric_failed.desc:
"""The number of times the hook execution failed"""
metric_failed.label:
"""Failed executions count"""

metric_max_rate.desc:
"""Maximum call rate of hooks"""
metric_max_rate.label:
"""Max hook call rate"""

metric_rate.desc:
"""The call rate of hooks"""
metric_rate.label:
"""Hook call rate"""

metric_succeed.desc:
"""The number of times the hooks execution successful"""
metric_succeed.label:
"""Successful executions count"""

metrics.desc:
"""Metrics information"""
metrics.label:
"""Metrics information"""

move_api.desc:
"""Move the server.
NOTE: The position should be "front | rear | before:{name} | after:{name}"""
move_api.label:
"""Change order of execution for registered Exhook server"""

move_position.desc:
"""The target position to be moved"""
move_position.label:
"""Target position"""

node.desc:
"""Node name"""
node.label:
"""Node name"""

node_hook_metrics.desc:
"""Metrics information of this hook in all nodes"""
node_hook_metrics.label:
"""Node-wise hook metrics"""

node_metrics.desc:
"""Metrics information of this server in all nodes"""
node_metrics.label:
"""Node-wise server metrics"""

node_status.desc:
"""status of this server in all nodes"""
node_status.label:
"""Node-wise server status"""

server_metrics.desc:
"""Metrics information of this server in the current node"""
server_metrics.label:
"""Server metrics"""

server_name.desc:
"""The Exhook server name"""
server_name.label:
"""Server name"""

status.desc:
"""The status of Exhook server.<br/>
connected: connection succeeded<br/>
connecting: connection failed, reconnecting<br/>
disconnected: failed to connect and didn't reconnect<br/>
disabled: this server is disabled<br/>
error: failed to view the status of this server"""
status.label:
"""Server status"""

update_server.desc:
"""Update the server"""
update_server.label:
"""Update the server"""

}

emqx_exhook_schema {

auto_reconnect.desc:
"""Whether to automatically reconnect (initialize) the gRPC server.
When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks."""

enable.desc:
"""Enable this Exhook server"""

failed_action.desc:
"""The value that is returned when the request to the gRPC server fails for any reason"""

keepalive.desc:
"""Enables/disables periodic transmission on a connected socket when no other data is exchanged.
If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process."""

name.desc:
"""Name of the exhook server"""

nodelay.desc:
"""If true, option TCP_NODELAY is turned on for the socket,
which means that also small amounts of data are sent immediately"""

pool_size.desc:
"""The process pool size for gRPC client"""

recbuf.desc:
"""The minimum size of receive buffer to use for the socket"""

request_timeout.desc:
"""The timeout of request gRPC server"""

servers.desc:
"""List of exhook servers"""

sndbuf.desc:
"""The minimum size of send buffer to use for the socket"""

socket_options.desc:
"""Connection socket options"""

url.desc:
"""URL of the gRPC server"""

}

emqx_exproto_schema {

exproto.desc:
"""The Extension Protocol configuration"""

exproto_grpc_handler_address.desc:
"""gRPC server address."""

exproto_grpc_handler_service_name.desc:
"""The service name to handle the connection events.
In the initial version, we expected to use streams to improve the efficiency
of requests in `ConnectionHandler`. But unfortunately, events between different
streams are out of order. It causes the `OnSocketCreated` event to may arrive
later than `OnReceivedBytes`.
So we added the `ConnectionUnaryHandler` service since v5.0.25 and forced
the use of Unary in it to avoid ordering problems."""

exproto_grpc_handler_ssl.desc:
"""SSL configuration for the gRPC client."""

exproto_grpc_server_bind.desc:
"""Listening address and port for the gRPC server."""

exproto_grpc_server_ssl.desc:
"""SSL configuration for the gRPC server."""

exproto_handler.desc:
"""Configurations for request to <code>ConnectionHandler</code> service"""

exproto_server.desc:
"""Configurations for starting the <code>ConnectionAdapter</code> service"""

}

emqx_ft_api {

file_list.desc:
"""List all uploaded files."""

file_list_transfer.desc:
"""List a file uploaded during specified transfer, identified by client id and file id."""

}

emqx_ft_storage_exporter_fs_api {

file_get.desc:
"""Get a file by its id."""

}

emqx_ft_schema {

enable.desc:
"""Enable the File Transfer feature.<br/>
Enabling File Transfer implies reserving special MQTT topics in order to serve the protocol.<br/>
This toggle also affects the availability of the File Transfer REST API and
storage-dependent background activities (e.g. garbage collection)."""

init_timeout.desc:
"""Timeout for EMQX to initialize the file transfer.<br/>
After reaching the timeout (e.g. due to system is overloaded), the PUBACK message for `init` will contain error code (0x80)."""

assemble_timeout.desc:
"""Timeout for assembling and exporting file segments into a final file.<br/>
After reaching the timeout (e.g. due to system is overloaded), the PUBACK message for `fin` will contain error code (0x80)"""

store_segment_timeout.desc:
"""Timeout for storing a file segment.<br/>
After reaching the timeout (e.g. due to system overloaded), the PUBACK message will contain error code (0x80)."""

backend_enable.desc:
"""Whether to enable this backend."""

storage_backend.desc:
"""Storage settings for file transfer."""

local_storage.desc:
"""Local file system backend to store uploaded fragments and temporary data."""

local_storage_segments.desc:
"""Settings for local segments storage, which include uploaded transfer fragments and temporary data."""

local_storage_segments_root.desc:
"""File system path to keep uploaded fragments and temporary data."""

local_storage_exporter_backend.desc:
"""Exporter for the local file system storage backend.<br/>
Exporter defines where and how fully transferred and assembled files are stored."""

local_storage_exporter.desc:
"""Exporter to the local file system."""

s3_exporter.desc:
"""Exporter to the S3 API compatible object storage."""

local_storage_exporter_root.desc:
"""Directory where the uploaded files are kept."""

local_storage_segments_gc.desc:
"""Garbage collection settings for the intermediate and temporary files in the local file system."""

storage_gc_interval.desc:
"""Interval of periodic garbage collection."""

storage_gc_max_segments_ttl.desc:
"""Maximum TTL of a segment kept in the local file system.<br/>
This is a hard limit: no segment will outlive this TTL, even if some file transfer specifies a
TTL more than that."""

storage_gc_min_segments_ttl.desc:
"""Minimum TTL of a segment kept in the local file system.<br/>
This is a hard limit: no segment will be garbage collected before reaching this TTL,
even if some file transfer specifies a TTL less than that."""

}

emqx_gateway_api {

delete_gateway.desc:
"""Unload the specified gateway"""

enable_gateway.desc:
"""Enable a gateway by confs."""

gateway_created_at.desc:
"""The Gateway created datetime"""

gateway_current_connections.desc:
"""The Gateway current connected connections/clients"""

gateway_enable_in_path.desc:
"""Whether to enable this gateway"""

gateway_listener_id.desc:
"""Listener ID"""

gateway_listener_name.desc:
"""Listener Name"""

gateway_listener_running.desc:
"""Listener Running status"""

gateway_listener_type.desc:
"""Listener Type"""

gateway_listeners.desc:
"""The Gateway listeners overview"""

gateway_max_connections.desc:
"""The Gateway allowed maximum connections/clients"""

gateway_name.desc:
"""Gateway Name"""

gateway_name_in_qs.desc:
"""Gateway Name.<br/>
It's enum with `stomp`, `mqttsn`, `coap`, `lwm2m`, `exproto`"""

gateway_node_status.desc:
"""The status of the gateway on each node in the cluster"""

gateway_started_at.desc:
"""The Gateway started datetime"""

gateway_status.desc:
"""Gateway status"""

gateway_status_in_qs.desc:
"""Filter gateways by status.<br/>
It is enum with `running`, `stopped`, `unloaded`"""

gateway_stopped_at.desc:
"""The Gateway stopped datetime"""

get_gateway.desc:
"""Get the gateway configurations"""

list_gateway.desc:
"""This API returns an overview info for the specified or all gateways.
including current running status, number of connections, listener status, etc."""

node.desc:
"""Node Name"""

update_gateway.desc:
"""Update the gateway basic configurations and running status.<br/>
Note: The Authentication and Listener configurations should be updated by other special APIs."""

}

emqx_gateway_api_authn {

add_authn.desc:
"""Enables the authenticator for client authentication for the specified gateway. <br/>
When the authenticator is not configured or turned off, all client connections are assumed to be allowed. <br/>
Note: Only one authenticator is allowed to be enabled at a time in the gateway, rather than allowing multiple authenticators to be configured to form an authentication chain as in MQTT."""

add_user.desc:
"""Add user for the authenticator (only supports built_in_database)."""

delete_authn.desc:
"""Delete the authenticator of the specified gateway."""

delete_user.desc:
"""Delete the user for the gateway authenticator (only supports built_in_database)"""

get_authn.desc:
"""Gets the configuration of the specified gateway authenticator.<br/>
Returns 404 when gateway or authentication is not enabled."""

get_user.desc:
"""Get user info from the gateway authenticator (only supports built_in_database)"""

import_users.desc:
"""Import users into the gateway authenticator (only supports built_in_database)"""

is_superuser.desc:
"""Is superuser"""

like_user_id.desc:
"""Fuzzy search using user ID (username or clientid), only supports search by substring."""

list_users.desc:
"""Get the users for the authenticator (only supported by <code>built_in_database</code>)."""

update_authn.desc:
"""Update the configuration of the specified gateway authenticator, or disable the authenticator."""

update_user.desc:
"""Update the user info for the gateway authenticator (only supports built_in_database)"""

user_id.desc:
"""User ID"""

}

emqx_gateway_api_clients {

disconnected_at.desc:
"""Client offline time, This field is only valid and returned when connected is false"""

heap_size.desc:
"""Process heap size with the unit of byte"""

send_oct.desc:
"""Number of bytes sent"""

get_client.desc:
"""Get the gateway client information"""

param_gte_created_at.desc:
"""Match the session created datetime greater than a certain value"""

param_conn_state.desc:
"""Match the client's connection state"""

send_pkt.desc:
"""Number of protocol packets sent"""

clean_start.desc:
"""Indicate whether the client is using a brand new session"""

inflight_cnt.desc:
"""Current length of inflight"""

delete_subscription.desc:
"""Delete a subscriptions membership"""

param_lte_connected_at.desc:
"""Match the client socket connected datatime less than a certain value"""

node.desc:
"""Name of the node to which the client is connected"""

awaiting_rel_cnt.desc:
"""Number of awaiting acknowledge packet"""

rap.desc:
"""Retain as Published option, enum: 0, 1"""

inflight_max.desc:
"""Maximum length of inflight"""

param_username.desc:
"""Match the client's Username"""

param_like_endpoint_name.desc:
"""Use sub-string to match lwm2m client's endpoint name"""

created_at.desc:
"""Session creation time"""

sub_props.desc:
"""Subscription properties"""

list_clients.desc:
"""Get the gateway client list"""

subscriptions_cnt.desc:
"""Number of subscriptions established by this client"""

mailbox_len.desc:
"""Process mailbox size"""

send_cnt.desc:
"""Number of socket packets sent"""

rh.desc:
"""Retain Handling option, enum: 0, 1, 2"""

connected.desc:
"""Whether the client is connected"""

qos.desc:
"""QoS level, enum: 0, 1, 2"""

ip_address.desc:
"""Client's IP address"""

param_gte_connected_at.desc:
"""Match the client socket connected datetime greater than a certain value"""

awaiting_rel_max.desc:
"""Maximum allowed number of awaiting PUBREC packet"""

param_like_username.desc:
"""Use sub-string to match client's username"""

nl.desc:
"""No Local option, enum: 0, 1"""

param_like_clientid.desc:
"""Use sub-string to match client's ID"""

param_lte_created_at.desc:
"""Match the session created datetime less than a certain value"""

topic.desc:
"""Topic Filter/Name"""

proto_ver.desc:
"""Protocol version used by the client"""

mountpoint.desc:
"""Topic mountpoint"""

proto_name.desc:
"""Client protocol name"""

param_lte_lifetime.desc:
"""Match the lwm2m client registered lifetime less than a certain value"""

port.desc:
"""Client's port"""

connected_at.desc:
"""Client connection time"""

expiry_interval.desc:
"""Session expiration interval, with the unit of second"""

username.desc:
"""Username of client when connecting"""

param_clean_start.desc:
"""Match the client's clean start flag"""

recv_msg.desc:
"""Number of message packets received"""

list_subscriptions.desc:
"""Get the gateway client subscriptions"""

recv_oct.desc:
"""Number of bytes received"""

keepalive.desc:
"""Keepalive time, with the unit of second"""

param_clientid.desc:
"""Match the client's ID"""

subscriptions_max.desc:
"""Maximum number of subscriptions allowed by this client"""

param_ip_address.desc:
"""Match the client's ip address"""

mqueue_max.desc:
"""Maximum length of message queue"""

mqueue_dropped.desc:
"""Number of messages dropped by the message queue due to exceeding the length"""

subid.desc:
"""Only stomp protocol, a unique identity for the subscription. range: 1-65535."""

clientid.desc:
"""Client ID"""

kick_client.desc:
"""Kick out the gateway client"""

is_bridge.desc:
"""Indicates whether the client is connected via bridge"""

lifetime.desc:
"""LwM2M Life time"""

send_msg.desc:
"""Number of message packets sent"""

add_subscription.desc:
"""Create a subscription membership"""

param_endpoint_name.desc:
"""Match the lwm2m client's endpoint name"""

param_node.desc:
"""Match the client's node name"""

recv_cnt.desc:
"""Number of socket packets received"""

recv_pkt.desc:
"""Number of protocol packets received"""

endpoint_name.desc:
"""The LwM2M client endpoint name"""

param_proto_ver.desc:
"""Match the client's protocol version"""

reductions.desc:
"""Erlang reduction"""

param_gte_lifetime.desc:
"""Match the lwm2m client registered lifetime greater than a certain value"""

mqueue_len.desc:
"""Current length of message queue"""

}

emqx_gateway_api_listeners {

add_listener.desc:
"""Create the gateway listener.<br/>
Note: For listener types not supported by a gateway, this API returns `400: BAD_REQUEST`."""

add_listener_authn.desc:
"""Enable authenticator for specified listener for client authentication.<br/>
When authenticator is enabled for a listener, all clients connecting to that listener will use that authenticator for authentication."""

add_user.desc:
"""Add user for the authenticator (only supports built_in_database)"""

current_connections.desc:
"""Current Connections"""

delete_listener.desc:
"""Delete the gateway listener. All connected clients under the deleted listener will be disconnected."""

delete_listener_authn.desc:
"""Remove authenticator for the listener."""

delete_user.desc:
"""Delete the user for the gateway authenticator (only supports built_in_database)"""

get_listener.desc:
"""Get the gateway listener configs"""

get_listener_authn.desc:
"""Get the listener's authenticator configs."""

get_user.desc:
"""Get user info from the gateway authenticator (only supports built_in_database)"""

import_users.desc:
"""Import users into the gateway authenticator (only supports built_in_database)"""

list_listeners.desc:
"""Gets a list of gateway listeners. This interface returns all the configs of the listener (including the authenticator on that listener), as well as the status of that listener running in the cluster."""

list_users.desc:
"""Get the users for the authenticator (only supported by <code>built_in_database</code>)"""

listener_id.desc:
"""Listener ID"""

listener_node_status.desc:
"""listener status of each node in the cluster"""

listener_status.desc:
"""listener status"""

node.desc:
"""Node Name"""

update_listener.desc:
"""Update the gateway listener. The listener being updated performs a restart and all clients connected to that listener will be disconnected."""

update_listener_authn.desc:
"""Update authenticator configs for the listener, or disable/enable it."""

update_user.desc:
"""Update the user info for the gateway authenticator (only supports built_in_database)"""

}

emqx_gateway_schema {

dtls_listener_acceptors.desc:
"""Size of the acceptor pool."""

dtls_listener_dtls_opts.desc:
"""DTLS socket options"""

gateway_common_authentication.desc:
"""Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>
 in listener configs"""

gateway_common_clientinfo_override.desc:
"""ClientInfo override."""

gateway_common_clientinfo_override_clientid.desc:
"""Template for overriding clientid."""

gateway_common_clientinfo_override_password.desc:
"""Template for overriding password."""

gateway_common_clientinfo_override_username.desc:
"""Template for overriding username."""

gateway_common_enable.desc:
"""Whether to enable this gateway"""

gateway_common_enable_stats.desc:
"""Whether to enable client process statistic"""

gateway_common_idle_timeout.desc:
"""The idle time of the client connection process. It has two purposes:
  1. A newly created client process that does not receive any client requests after that time will be closed directly.
  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources."""

gateway_common_listener_access_rules.desc:
"""The access control rules for this listener.
See: https://github.com/emqtt/esockd#allowdeny"""

gateway_common_listener_bind.desc:
"""The IP address and port that the listener will bind."""

gateway_common_listener_enable.desc:
"""Enable the listener."""

gateway_common_listener_enable_authn.desc:
"""Set <code>true</code> (default) to enable client authentication on this listener. 
When set to <code>false</code> clients will be allowed to connect without authentication."""

gateway_common_listener_max_conn_rate.desc:
"""Maximum connections per second."""

gateway_common_listener_max_connections.desc:
"""Maximum number of concurrent connections."""

gateway_mountpoint.desc:
"""When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message is delivered to the subscriber.
The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint` set to `some_tenant`,
then the client actually subscribes to the topic `some_tenant/t`.
Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`,
the message is routed to all the clients subscribed `some_tenant/t`,
so client A will receive the message, with topic name `t`. Set to `""` to disable the feature.
Variables in mountpoint string:<br/>
  - <code>${clientid}</code>: clientid<br/>
  - <code>${username}</code>: username"""

listener_name_to_settings_map.desc:
"""A map from listener names to listener settings."""

ssl_listener_options.desc:
"""SSL Socket options."""

tcp_listener_acceptors.desc:
"""Size of the acceptor pool."""

tcp_listener_proxy_protocol.desc:
"""Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""

tcp_listener_proxy_protocol_timeout.desc:
"""Timeout for proxy protocol.
EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""

tcp_listener_tcp_opts.desc:
"""Setting the TCP socket options."""

tcp_listeners.desc:
"""Settings for the TCP listeners."""

tcp_udp_listeners.desc:
"""Settings for the listeners."""

udp_listener_active_n.desc:
"""Specify the {active, N} option for the socket.
See: https://erlang.org/doc/man/inet.html#setopts-2"""

udp_listener_buffer.desc:
"""Size of the user-space buffer for the socket."""

udp_listener_recbuf.desc:
"""Size of the kernel-space receive buffer for the socket."""

udp_listener_reuseaddr.desc:
"""Allow local reuse of port numbers."""

udp_listener_sndbuf.desc:
"""Size of the kernel-space send buffer for the socket."""

udp_listener_udp_opts.desc:
"""Settings for the UDP sockets."""

udp_listeners.desc:
"""Settings for the UDP listeners."""

}

emqx_license_http_api {

desc_license_info_api.desc:
"""Get license info"""

desc_license_info_api.label:
"""License info"""

desc_license_key_api.desc:
"""Update a license key"""

desc_license_key_api.label:
"""Update license"""

}

emqx_license_schema {

connection_high_watermark_field.desc:
"""High watermark limit above which license connection quota usage alarms are activated"""

connection_high_watermark_field.label:
"""Connection high watermark"""

connection_low_watermark_field.desc:
"""Low watermark limit below which license connection quota usage alarms are deactivated"""

connection_low_watermark_field.label:
"""Connection low watermark"""

key_field.desc:
"""License string"""

key_field.label:
"""License string"""

license_root.desc:
"""Defines the EMQX Enterprise license. 


The default license has 100 connections limit, it is issued on 2023-01-09 and valid for 5 years (1825 days).

EMQX comes with a default trial license.  For production use, please 
visit https://www.emqx.com/apply-licenses/emqx to apply."""

license_root.label:
"""License"""

}

emqx_limiter_schema {

max_conn_rate.desc:
"""Maximum connection rate.<br/>
This is used to limit the connection rate for this node,
once the limit is reached, new connections will be deferred or refused"""
max_conn_rate.label:
"""Maximum Connection Rate"""

messages_rate.desc:
"""Messages publish rate.<br/>
This is used to limit the inbound message numbers for this node,
once the limit is reached, the restricted client will slow down and even be hung for a while."""
messages_rate.label:
"""Messages Publish Rate"""

bytes_rate.desc:
"""Data publish rate.<br/>
This is used to limit the inbound bytes rate for this node,
once the limit is reached, the restricted client will slow down and even be hung for a while."""
bytes_rate.label:
"""Data Publish Rate"""

bucket_cfg.desc:
"""Bucket Configs"""

bucket_cfg.label:
"""Buckets"""

burst.desc:
"""The burst, This value is based on rate.<br/>
 This value + rate = the maximum limit that can be achieved when limiter burst."""

burst.label:
"""Burst"""

bytes.desc:
"""The `bytes` limiter.
This is used to limit the inbound bytes rate for this EMQX node.
Once the limit is reached, the restricted client will be slow down even be hung for a while."""

bytes.label:
"""Bytes"""

client.desc:
"""The rate limit for each user of the bucket"""

client.label:
"""Per Client"""

connection.desc:
"""The connection limiter.
This is used to limit the connection rate for this EMQX node.
Once the limit is reached, new connections will be refused"""

connection.label:
"""Connection"""

divisible.desc:
"""Is it possible to split the number of requested tokens?"""

divisible.label:
"""Divisible"""

failure_strategy.desc:
"""The strategy when all the retries failed."""

failure_strategy.label:
"""Failure Strategy"""

initial.desc:
"""The initial number of tokens for this bucket."""

initial.label:
"""Initial"""

internal.desc:
"""Limiter for EMQX internal app."""

low_watermark.desc:
"""If the remaining tokens are lower than this value,
the check/consume will succeed, but it will be forced to wait for a short period of time."""

low_watermark.label:
"""Low Watermark"""

max_retry_time.desc:
"""The maximum retry time when acquire failed."""

max_retry_time.label:
"""Max Retry Time"""

message_routing.desc:
"""The message routing limiter.
This is used to limit the forwarding rate for this EMQX node.
Once the limit is reached, new publish will be refused"""

message_routing.label:
"""Message Routing"""

messages.desc:
"""The `messages` limiter.
This is used to limit the inbound message numbers for this EMQX node
Once the limit is reached, the restricted client will be slow down even be hung for a while."""

messages.label:
"""Messages"""

rate.desc:
"""Rate for this bucket."""

rate.label:
"""Rate"""

}

emqx_lwm2m_api {

dataType.desc:
"""Data Type"""

lookup_resource.desc:
"""Look up a resource"""

name.desc:
"""Resource Name"""

observe_resource.desc:
"""Observe or Cancel observe a resource"""

operations.desc:
"""Resource Operations"""

path.desc:
"""Resource Path"""

read_resource.desc:
"""Send a read command to a resource"""

write_resource.desc:
"""Send a write command to a resource"""

}

emqx_lwm2m_schema {

lwm2m.desc:
"""The LwM2M Gateway configuration. This gateway only supports the v1.0.1 protocol."""

lwm2m_auto_observe.desc:
"""Automatically observe the object list of REGISTER packet."""

lwm2m_lifetime_max.desc:
"""Maximum value of lifetime allowed to be set by the LwM2M client."""

lwm2m_lifetime_min.desc:
"""Minimum value of lifetime allowed to be set by the LwM2M client."""

lwm2m_qmode_time_window.desc:
"""The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.
For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory."""

lwm2m_translators.desc:
"""Topic configuration for LwM2M's gateway publishing and subscription."""

lwm2m_translators_command.desc:
"""The topic for receiving downstream commands.
For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client"""

lwm2m_translators_notify.desc:
"""The topic for gateway to publish the notify events from LwM2M client.
After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes"""

lwm2m_translators_register.desc:
"""The topic for gateway to publish the register events from LwM2M client."""

lwm2m_translators_response.desc:
"""The topic for gateway to publish the acknowledge events from LwM2M client"""

lwm2m_translators_update.desc:
"""The topic for gateway to publish the update events from LwM2M client"""

lwm2m_update_msg_publish_condition.desc:
"""Policy for publishing UPDATE event message.<br/>
  - always: send update events as long as the UPDATE request is received.<br/>
  - contains_object_list: send update events only if the UPDATE request carries any Object List"""

lwm2m_xml_dir.desc:
"""The Directory for LwM2M Resource definition."""

translator.desc:
"""MQTT topic that corresponds to a particular type of event."""

translator_qos.desc:
"""QoS Level"""

translator_topic.desc:
"""Topic Name"""

}

emqx_mgmt_api_alarms {

activate_at.desc:
"""Alarm start time, using rfc3339 standard time format."""

deactivate_at.desc:
"""Alarm end time, using rfc3339 standard time format."""

delete_alarms_api.desc:
"""Remove all historical alarms."""
delete_alarms_api.label:
"""Remove all historical alarms."""

delete_alarms_api_response204.desc:
"""Historical alarms have been cleared successfully."""

details.desc:
"""Alarm details, provides more alarm information, mainly for program processing."""

duration.desc:
"""Indicates how long the alarm has been active in milliseconds."""

get_alarms_qs_activated.desc:
"""It is used to specify the alarm type of the query.
When true, it returns the currently activated alarm,
and when it is false, it returns the historical alarm.
The default is false."""

list_alarms_api.desc:
"""List currently activated alarms or historical alarms, determined by query parameters."""
list_alarms_api.label:
"""List alarms"""

message.desc:
"""Alarm message, which describes the alarm content in a human-readable format."""

name.desc:
"""Alarm name, used to distinguish different alarms."""

node.desc:
"""The name of the node that triggered this alarm."""

}

emqx_mgmt_api_api_keys {

api_key_list.desc:
"""Return api_key list"""
api_key_list.label:
"""Return api_key list"""

create_new_api_key.desc:
"""Create new api_key"""
create_new_api_key.label:
"""Create new api_key"""

get_api_key.desc:
"""Return the specific api_key"""
get_api_key.label:
"""Return the specific api_key"""

update_api_key.desc:
"""Update the specific api_key"""
update_api_key.label:
"""Update the specific api_key"""

delete_api_key.desc:
"""Delete the specific api_key"""
delete_api_key.label:
"""Delete the specific api_key"""

format.desc:
"""Unique and format by [a-zA-Z0-9-_]"""
format.label:
"""Unique and format by [a-zA-Z0-9-_]"""

}

emqx_mgmt_api_banned {

as.desc:
"""Ban method, which can be client ID, username or IP address."""

as.label:
"""Ban Method"""

at.desc:
"""The start time of the ban, the format is rfc3339, the default is the time when the operation was initiated."""

at.label:
"""Ban Time"""

by.desc:
"""Initiator of the ban."""

by.label:
"""Ban Initiator"""

create_banned_api.desc:
"""Add a client ID, username or IP address to the blacklist."""
create_banned_api.label:
"""Ban client ID, username or IP address"""

create_banned_api_response400.desc:
"""Bad request, possibly due to wrong parameters or the existence of a banned object."""

delete_banned_api.desc:
"""Remove a client ID, username or IP address from the blacklist."""
delete_banned_api.label:
"""Unban a client ID, username or IP address"""

delete_banned_api_response404.desc:
"""The banned object was not found in the blacklist."""

list_banned_api.desc:
"""List all currently banned client IDs, usernames and IP addresses."""
list_banned_api.label:
"""List all banned client IDs"""

reason.desc:
"""Ban reason, record the reason why the current object was banned."""

reason.label:
"""Ban Reason"""

until.desc:
"""The end time of the ban, the format is rfc3339, the default is the time when the operation was initiated + 1 year."""

until.label:
"""Ban End Time"""

who.desc:
"""Ban object, specific client ID, username or IP address."""

who.label:
"""Ban Object"""

}

emqx_mgmt_api_clients {

list_clients.desc:
"""List clients"""
list_clients.label:
"""List clients"""

kickout_clients.desc:
"""Kick out a batch of client by client IDs"""
kickout_clients.label:
"""Kick out a batch of client by client IDs"""

clients_info_from_id.desc:
"""Get clients info by client ID"""
clients_info_from_id.label:
"""Get clients info by client ID"""

kick_client_id.desc:
"""Kick out client by client ID"""
kick_client_id.label:
"""Kick out client by client ID"""

get_authz_cache.desc:
"""Get client authz cache in the cluster."""
get_authz_cache.label:
"""Get client authz cache in the cluster."""

clean_authz_cache.desc:
"""Clean client authz cache in the cluster."""
clean_authz_cache.label:
"""Clean client authz cache in the cluster."""

get_client_subs.desc:
"""Get client subscriptions"""
get_client_subs.label:
"""Get client subscriptions"""

subscribe.desc:
"""Subscribe"""
subscribe.label:
"""Subscribe"""

subscribe_g.desc:
"""Subscribe bulk"""
subscribe_g.label:
"""Subscribe bulk"""

unsubscribe.desc:
"""Unsubscribe"""
unsubscribe.label:
"""Unsubscribe"""

unsubscribe_g.desc:
"""Unsubscribe bulk"""
unsubscribe_g.label:
"""Unsubscribe bulk"""

set_keepalive_seconds.desc:
"""Set the online client keepalive by seconds"""
set_keepalive_seconds.label:
"""Set the online client keepalive by seconds"""

}

emqx_mgmt_api_cluster {

get_cluster_info.desc:
"""Get cluster info"""
get_cluster_info.label:
"""Get cluster info"""

invite_node.desc:
"""Invite node to cluster"""
invite_node.label:
"""Invite node to cluster"""

force_remove_node.desc:
"""Force leave node from cluster"""
force_remove_node.label:
"""Force leave node from cluster"""

}

emqx_mgmt_api_configs {

get_configs.desc:
"""Get all the configurations of the specified keys, including hot and non-hot updatable items."""
get_configs.label:
"""Get all the configurations."""

update_configs.desc:
"""Update the configurations of the specified keys."""
update_configs.label:
"""Update Configurations."""

node_name.desc:
"""Node's name. Will deprecated in 5.2.0."""
node_name.label:
"""Node's name (deprecated)."""

rest_conf_query.desc:
"""Reset the config entry specified by the query string parameter `conf_path`.<br/>
- For a config entry that has default value, this resets it to the default value;
- For a config entry that has no default value, an error 400 will be returned"""
rest_conf_query.label:
"""Reset the config entry with query"""

get_global_zone_configs.desc:
"""Get the global zone configs"""
get_global_zone_configs.label:
"""Get the global zone configs"""

update_global_zone_configs.desc:
"""Update global zone configs"""
update_global_zone_configs.label:
"""Update global zone configs"""

get_node_level_limiter_configs.desc:
"""Get the node-level limiter configs"""
get_node_level_limiter_configs.label:
"""Get the node-level limiter configs"""

update_node_level_limiter_configs.desc:
"""Update the node-level limiter configs"""
update_node_level_limiter_configs.label:
"""Update the node-level limiter configs"""

}

emqx_mgmt_api_key_schema {

api_key.desc:
"""API Key, can be used to request API other than the management API key and the Dashboard user management API"""

api_key.label:
"""API Key"""

bootstrap_file.desc:
"""Bootstrap file is used to add an api_key when emqx is launched,
      the format is:
       ```
       7e729ae70d23144b:2QILI9AcQ9BYlVqLDHQNWN2saIjBV4egr1CZneTNKr9CpK
       ec3907f865805db0:Ee3taYltUKtoBVD9C3XjQl9C6NXheip8Z9B69BpUv5JxVHL
       ```"""

bootstrap_file.label:
"""Initialize api_key file."""

}

emqx_mgmt_api_listeners {

list_node_live_statuses.desc:
"""List all running node's listeners live status. group by listener type"""
list_node_live_statuses.label:
"""List listeners live status"""

list_listeners.desc:
"""List all running node's listeners for the specified type."""
list_listeners.label:
"""List listeners per type"""

listener_type.desc:
"""Listener type"""
listener_type.label:
"""Listener type"""

create_on_all_nodes.desc:
"""Create the specified listener on all nodes."""
create_on_all_nodes.label:
"""Create listener"""

list_by_id.desc:
"""List all running node's listeners for the specified id."""
list_by_id.label:
"""List listeners per ID"""

update_lisener.desc:
"""Update the specified listener on all nodes."""
update_lisener.label:
"""Update listener"""

delete_on_all_nodes.desc:
"""Delete the specified listener on all nodes."""
delete_on_all_nodes.label:
"""Delete listener"""

start_on_all_nodes.desc:
"""Start the listener on all nodes."""
start_on_all_nodes.label:
"""Start listener"""

stop_on_all_nodes.desc:
"""Stop the listener on all nodes."""
stop_on_all_nodes.label:
"""Stop listener"""

restart_on_all_nodes.desc:
"""Restart listeners on all nodes."""
restart_on_all_nodes.label:
"""Restart listener"""


}

emqx_mgmt_api_metrics {

emqx_metrics.desc:
"""EMQX metrics"""
emqx_metrics.label:
"""EMQX metrics"""

}

emqx_mgmt_api_nodes {

list_nodes.desc:
"""List EMQX nodes"""
list_nodes.label:
"""List EMQX nodes"""

get_node_info.desc:
"""Get node info"""
get_node_info.label:
"""Get node info"""

get_node_metrics.desc:
"""Get node run-time counter metrics. Such as received or sent bytes or messages, the number of succeeded or failed authentications or authorizations, etc."""
get_node_metrics.label:
"""Get node metrics"""

get_node_stats.desc:
"""Get node run-time stats. Such as the number of topics, connections, etc."""
get_node_stats.label:
"""Get node stats"""

}

emqx_mgmt_api_publish {

error_message.desc:
"""Describes the failure reason in detail."""

message_id.desc:
"""A globally unique message ID for correlation/tracing."""

message_properties.desc:
"""The Properties of the PUBLISH message."""

msg_content_type.desc:
"""The Content Type MUST be a UTF-8 Encoded String."""

msg_correlation_data.desc:
"""Identifier of the Correlation Data. The Server MUST send the Correlation Data unaltered to all subscribers receiving the Application Message."""

msg_message_expiry_interval.desc:
"""Identifier of the Message Expiry Interval. If the Message Expiry Interval has passed and the Server has not managed to start onward delivery to a matching subscriber, then it MUST delete the copy of the message for that subscriber."""

msg_payload_format_indicator.desc:
"""0 (0x00) Byte Indicates that the Payload is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.
1 (0x01) Byte Indicates that the Payload is UTF-8 Encoded Character Data. The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification and restated in RFC 3629."""

msg_response_topic.desc:
"""Identifier of the Response Topic.The Response Topic MUST be a UTF-8 Encoded, It MUST NOT contain wildcard characters."""

msg_user_properties.desc:
"""The User-Property key-value pairs. Note: in case there are duplicated keys, only the last one will be used."""

payload.desc:
"""The MQTT message payload."""

payload_encoding.desc:
"""MQTT Payload Encoding, <code>base64</code> or <code>plain</code>. When set to <code>base64</code>, the message is decoded before it is published."""

publish_api.desc:
"""Possible HTTP status response codes are:<br/>
<code>200</code>: The message is delivered to at least one subscriber;<br/>
<code>202</code>: No matched subscribers;<br/>
<code>400</code>: Message is invalid. for example bad topic name, or QoS is out of range;<br/>
<code>503</code>: Failed to deliver the message to subscriber(s)"""

publish_api.label:
"""Publish a message"""

publish_bulk_api.desc:
"""Possible HTTP response status code are:<br/>
200: All messages are delivered to at least one subscriber;<br/>
202: At least one message was not delivered to any subscriber;<br/>
400: At least one message is invalid. For example bad topic name, or QoS is out of range;<br/>
503: Failed to deliver at least one of the messages;<br/>

In case there is at lest one invalid message in the batch, the HTTP response body
is the same as for <code>/publish</code> API.<br/>
Otherwise the HTTP response body is an array of JSON objects indicating the publish
result of each individual message in the batch."""

publish_bulk_api.label:
"""Publish a batch of messages"""

qos.desc:
"""MQTT message QoS"""

reason_code.desc:
"""The MQTT reason code, as the same ones used in PUBACK packet.<br/>
Currently supported codes are:<br/>

16(0x10): No matching subscribers;<br/>
131(0x81): Error happened when dispatching the message. e.g. during EMQX restart;<br/>
144(0x90): Topic name invalid;<br/>
151(0x97): Publish rate limited, or message size exceeded limit. The global size limit can be configured with <code>mqtt.max_packet_size</code><br/>
NOTE: The message size is estimated with the received topic and payload size, meaning the actual size of serialized bytes (when sent to MQTT subscriber)
might be slightly over the limit."""

retain.desc:
"""A boolean field to indicate if this message should be retained."""

topic_name.desc:
"""Topic Name"""

}

emqx_mgmt_api_stats {

emqx_stats.desc:
"""EMQX stats"""
emqx_stats.label:
"""EMQX stats"""

}

emqx_mgmt_api_status {

get_status_api.desc:
"""Serves as a health check for the node.
Returns response to describe the status of the node and the application.

This endpoint requires no authentication.

Returns status code 200 if the EMQX application is up and running, 503 otherwise.
This API was introduced in v5.0.10.
The GET `/status` endpoint (without the `/api/...` prefix) is also an alias to this endpoint and works in the same way.
This alias has been available since v5.0.0.

Starting from v5.0.25 or e5.0.4, you can also use 'format' parameter to get JSON format information."""

get_status_api.label:
"""Service health check"""

get_status_response200.desc:
"""If 'format' parameter is 'json', then it returns a JSON like below:<br/>
{
  "rel_vsn": "v5.0.23",
  "node_name": "emqx@127.0.0.1",
  "broker_status": "started",
  "app_status": "running"
}
<br/>
Otherwise it returns free text strings as below:<br/>
Node emqx@127.0.0.1 is started
emqx is running"""

get_status_response503.desc:
"""When EMQX application is temporary not running or being restarted, it may return 'emqx is not_running'.
If the 'format' parameter is provided 'json', then the 'app_status' field in the JSON object will be 'not_running'."""

get_status_api_format.desc:
"""Specify the response format, 'text' (default) to return the HTTP body in free text,
or 'json' to return the HTTP body with a JSON object."""

}

emqx_mgmt_api_subscriptions {

list_subs.desc:
"""List subscriptions"""
list_subs.label:
"""List subscriptions"""

}

emqx_mgmt_api_topics {

topic_list.desc:
"""Topics list"""
topic_list.label:
"""Topics list"""

topic_info_by_name.desc:
"""Lookup topic info by name"""
topic_info_by_name.label:
"""Lookup topic info by name"""

}

emqx_mgmt_api_trace {

list_all.desc:
"""List all trace"""
list_all.label:
"""List all trace"""

create_new.desc:
"""Create new trace"""
create_new.label:
"""Create new trace"""

clear_all.desc:
"""Clear all traces"""
clear_all.label:
"""Clear all traces"""

delete_trace.desc:
"""Delete specified trace"""
delete_trace.label:
"""Delete specified trace"""

stop_trace.desc:
"""Stop trace by name"""
stop_trace.label:
"""Stop trace by name"""

download_log_by_name.desc:
"""Download trace log by name"""
download_log_by_name.label:
"""Download trace log by name"""

trace_zip_file.desc:
"""A trace zip file"""
trace_zip_file.label:
"""A trace zip file"""

get_trace_file_metadata.desc:
"""get trace log file's metadata, such as size, last update time"""
get_trace_file_metadata.label:
"""get trace log file's metadata"""

view_trace_log.desc:
"""view trace log"""
view_trace_log.label:
"""view trace log"""

file_size.desc:
"""file size"""
file_size.label:
"""file size"""

file_mtime.desc:
"""The last time this file is modified."""
file_mtime.label:
"""file mtime"""

trace_name.desc:
"""Unique name of the trace. Only ascii letters in a-z, A-Z, 0-9 and underscore '_' are allowed."""
trace_name.label:
"""Unique name of the trace"""

filter_type.desc:
"""Filter type"""
filter_type.label:
"""Filter type"""

support_wildcard.desc:
"""Specify the topic or topic filter if the trace 'type' is 'topic'."""
support_wildcard.label:
"""MQTT Topic"""

mqtt_clientid.desc:
"""Specify the MQTT clientid if the trace 'type' is 'clientid'."""
mqtt_clientid.label:
"""MQTT clientid"""

client_ip_addess.desc:
"""Specify the client's IP address if the trace type is 'ip_address'."""
client_ip_addess.label:
"""Client IP Address"""

trace_status.desc:
"""trace status"""
trace_status.label:
"""trace status"""

time_format.desc:
"""rfc3339 timestamp or epoch second"""
time_format.label:
"""rfc3339 timestamp or epoch second"""

trace_log_size.desc:
"""trace log size"""
trace_log_size.label:
"""trace log size"""

node_name.desc:
"""Node name"""
node_name.label:
"""Node name"""

max_response_bytes.desc:
"""Maximum number of bytes to send in response"""
max_response_bytes.label:
"""Maximum response bytes"""

current_trace_offset.desc:
"""Offset from the current trace position."""
current_trace_offset.label:
"""Offset from the current trace position."""

}

emqx_modules_schema {

enable.desc:
"""Enable this feature"""

max_delayed_messages.desc:
"""Maximum number of delayed messages (0 is no limit)."""

rewrite.desc:
"""The topic rewriting function of EMQX supports rewriting topic A to topic B when the client subscribes to topics, publishes messages, and cancels subscriptions according to user-configured rules.
Each rewrite rule consists of three parts: subject filter, regular expression, and target expression.
Under the premise that the subject rewriting function is enabled, when EMQX receives a subject-based MQTT message such as a `PUBLISH` message,
it will use the subject of the message to sequentially match the subject filter part of the rule in the configuration file. If the match is successful,
the regular expression is used to extract the information in the subject, and then replaced with the target expression to form a new subject.
Variables in the format of `$N` can be used in the target expression to match the elements extracted from the regular expression.
The value of `$N` is the Nth element extracted from the regular expression. For example, `$1` is the regular expression. The first element extracted by the expression.
It should be noted that EMQX uses reverse order to read the rewrite rules in the configuration file.
When a topic can match the topic filter of multiple topic rewrite rules at the same time, EMQX will only use the first rule it matches. Rewrite.
If the regular expression in this rule does not match the subject of the MQTT message, the rewriting will fail, and no other rules will be attempted for rewriting.
Therefore, users need to carefully design MQTT message topics and topic rewriting rules when using them."""

rewrite.label:
"""Topic Rewrite"""

tr_action.desc:
"""Topic rewriting takes effect on the type of operation:
  - `subscribe`: Rewrite topic when client do subscribe.
  - `publish`: Rewrite topic when client do publish.
  - `all`: Both"""

tr_action.label:
"""Action"""

tr_dest_topic.desc:
"""Destination topic."""

tr_dest_topic.label:
"""Destination Topic"""

tr_re.desc:
"""Regular expressions"""

tr_source_topic.desc:
"""Source topic, specified by the client."""

tr_source_topic.label:
"""Source Topic"""

}

emqx_mongodb {

auth_source.desc:
"""Database name associated with the user's credentials."""

auth_source.label:
"""Auth Source"""

connect_timeout.desc:
"""The duration to attempt a connection before timing out."""

connect_timeout.label:
"""Connect Timeout"""

desc_rs.desc:
"""Settings for replica set."""

desc_rs.label:
"""Setting Replica Set"""

desc_sharded.desc:
"""Settings for sharded cluster."""

desc_sharded.label:
"""Setting Sharded Cluster"""

desc_single.desc:
"""Settings for a single MongoDB instance."""

desc_single.label:
"""Setting Single MongoDB"""

desc_topology.desc:
"""Topology of MongoDB."""

desc_topology.label:
"""Setting Topology"""

heartbeat_period.desc:
"""Controls when the driver checks the state of the MongoDB deployment. Specify the interval between checks, counted from the end of the previous check until the beginning of the next one. If the number of connections is increased (which will happen, for example, if you increase the pool size), you may need to increase this period as well to avoid creating too many log entries in the MongoDB log file."""

heartbeat_period.label:
"""Heartbeat period"""

local_threshold.desc:
"""The size of the latency window for selecting among multiple suitable MongoDB instances."""

local_threshold.label:
"""Local Threshold"""

max_overflow.desc:
"""The maximum number of additional workers that can be created when all workers in the pool are busy. This helps to manage temporary spikes in workload by allowing more concurrent connections to the MongoDB server."""

max_overflow.label:
"""Max Overflow Workers"""

min_heartbeat_period.desc:
"""Controls the minimum amount of time to wait between heartbeats."""

min_heartbeat_period.label:
"""Minimum Heartbeat Period"""

overflow_check_period.desc:
"""Period for checking if there are more workers than configured ("overflow")."""

overflow_check_period.label:
"""Overflow Check Period"""

overflow_ttl.desc:
"""Period of time before workers that exceed the configured pool size ("overflow") to be terminated."""

overflow_ttl.label:
"""Overflow TTL"""

r_mode.desc:
"""Read mode."""

r_mode.label:
"""Read Mode"""

replica_set_name.desc:
"""Name of the replica set."""

replica_set_name.label:
"""Replica Set Name"""

rs_mongo_type.desc:
"""Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode."""

rs_mongo_type.label:
"""Replica set"""

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The MongoDB default port 27017 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

server_selection_timeout.desc:
"""Specifies how long to block for server selection before throwing an exception."""

server_selection_timeout.label:
"""Server Selection Timeout"""

servers.desc:
"""A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`
For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.
A host entry has the following form: `Host[:Port]`.
The MongoDB default port 27017 is used if `[:Port]` is not specified."""

servers.label:
"""Servers"""

sharded_mongo_type.desc:
"""Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode."""

sharded_mongo_type.label:
"""Sharded cluster"""

single_mongo_type.desc:
"""Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode."""

single_mongo_type.label:
"""Standalone instance"""

socket_timeout.desc:
"""The duration to attempt to send or to receive on a socket before the attempt times out."""

socket_timeout.label:
"""Socket Timeout"""

srv_record.desc:
"""Use DNS SRV record."""

srv_record.label:
"""Srv Record"""

w_mode.desc:
"""Write mode."""

w_mode.label:
"""Write Mode"""

wait_queue_timeout.desc:
"""The maximum duration that a worker can wait for a connection to become available."""

wait_queue_timeout.label:
"""Wait Queue Timeout"""

}

emqx_mqttsn_schema {

mqttsn.desc:
"""The MQTT-SN Gateway configuration.
This gateway only supports the v1.2 protocol"""

mqttsn_broadcast.desc:
"""Whether to periodically broadcast ADVERTISE messages"""

mqttsn_enable_qos3.desc:
"""Allows connectionless clients to publish messages with a Qos of -1.
This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW"""

mqttsn_gateway_id.desc:
"""MQTT-SN Gateway ID.
When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value"""

mqttsn_predefined.desc:
"""The pre-defined topic IDs and topic names.
A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway"""

mqttsn_predefined_id.desc:
"""Topic ID. Range: 1-65535"""

mqttsn_predefined_topic.desc:
"""Topic Name"""

mqttsn_subs_resume.desc:
"""Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel"""

}

emqx_mysql {

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The MySQL default port 3306 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

}

emqx_node_rebalance_api {

load_rebalance_status.desc:
"""Get rebalance status of the current node"""

load_rebalance_status.label:
"""Get rebalance status"""

load_rebalance_global_status.desc:
"""Get status of all rebalance/evacuation processes across the cluster"""

load_rebalance_global_status.label:
"""Get global rebalance status"""

load_rebalance_availability_check.desc:
"""Check if the node is being evacuated or rebalanced"""

load_rebalance_availability_check.label:
"""Availability check"""

load_rebalance_start.desc:
"""Start rebalance process"""

load_rebalance_start.label:
"""Start rebalance"""

load_rebalance_stop.desc:
"""Stop rebalance process"""

load_rebalance_stop.label:
"""Stop rebalance"""

load_rebalance_evacuation_start.desc:
"""Start evacuation process"""

load_rebalance_evacuation_start.label:
"""Start evacuation"""

load_rebalance_evacuation_stop.desc:
"""Stop evacuation process"""

load_rebalance_evacuation_stop.label:
"""Stop evacuation"""

param_node.desc:
"""Node name"""

param_node.label:
"""Node name"""

wait_health_check.desc:
"""Time to wait before starting the rebalance/evacuation process, in seconds"""

wait_health_check.label:
"""Wait health check"""

conn_evict_rate.desc:
"""The rate of evicting connections, in connections per second"""

conn_evict_rate.label:
"""Connection eviction rate"""

sess_evict_rate.desc:
"""The rate of evicting sessions, in sessions per second"""

sess_evict_rate.label:
"""Session eviction rate"""

abs_conn_threshold.desc:
"""Maximum desired difference between the number of connections on the node and the average number of connections on the recipient nodes. Difference lower than this is the goal of the rebalance process."""

abs_conn_threshold.label:
"""Absolute connection threshold"""

rel_conn_threshold.desc:
"""Maximum desired fraction between the number of connections on the node and the average number of connections on the recipient nodes. Fraction lower than this is the goal of the rebalance process."""

rel_conn_threshold.label:
"""Relative connection threshold"""

abs_sess_threshold.desc:
"""Maximum desired difference between the number of sessions on the node and the average number of sessions on the recipient nodes. Difference lower than this is the goal of the evacuation process."""

abs_sess_threshold.label:
"""Absolute session threshold"""

rel_sess_threshold.desc:
"""Maximum desired fraction between the number of sessions on the node and the average number of sessions on the recipient nodes. Fraction lower than this is the goal of the evacuation process"""

rel_sess_threshold.label:
"""Relative session threshold"""

wait_takeover.desc:
"""Time to wait before starting session evacuation process, in seconds"""

wait_takeover.label:
"""Wait takeover"""

redirect_to.desc:
"""Server reference to redirect clients to (MQTTv5 Server redirection)"""

redirect_to.label:
"""Redirect to"""

migrate_to.desc:
"""Nodes to migrate sessions to"""

migrate_to.label:
"""Migrate to"""

rebalance_nodes.desc:
"""Nodes to participate in rebalance"""

rebalance_nodes.label:
"""Rebalance nodes"""

local_status_enabled.desc:
"""Whether the node is being evacuated"""

local_status_enabled.label:
"""Local evacuation status"""

local_status_process.desc:
"""The type of the task that is being performed on the node: 'evacuation' or 'rebalance'"""

local_status_process.label:
"""Task Type"""

local_status_state.desc:
"""The state of the process that is being performed on the node"""

local_status_state.label:
"""Rebalance/evacuation current state"""

local_status_coordinator_node.desc:
"""The node that is coordinating rebalance process"""

local_status_coordinator_node.label:
"""Coordinator node"""

local_status_connection_eviction_rate.desc:
"""The rate of evicting connections, in connections per second"""

local_status_connection_eviction_rate.label:
"""Connection eviction rate"""

local_status_session_eviction_rate.desc:
"""The rate of evicting sessions, in sessions per second"""

local_status_session_eviction_rate.label:
"""Session eviction rate"""

local_status_connection_goal.desc:
"""The number of connections that the node should have after the rebalance/evacuation process"""

local_status_connection_goal.label:
"""Connection goal"""

local_status_session_goal.desc:
"""The number of sessions that the node should have after the evacuation process"""

local_status_session_goal.label:
"""Session goal"""

local_status_disconnected_session_goal.desc:
"""The number of disconnected sessions that the node should have after the rebalance process"""

local_status_disconnected_session_goal.label:
"""Disconnected session goal"""

local_status_session_recipients.desc:
"""List of nodes to which sessions are being evacuated"""

local_status_session_recipients.label:
"""Session recipients"""

local_status_recipients.desc:
"""List of nodes to which connections/sessions are being evacuated during rebalance"""

local_status_recipients.label:
"""Recipients"""

local_status_stats.desc:
"""Statistics of the evacuation/rebalance process"""

local_status_stats.label:
"""Statistics"""

status_stats_initial_connected.desc:
"""The number of connections on the node before the evacuation/rebalance process"""

status_stats_initial_connected.label:
"""Initial connected"""

status_stats_current_connected.desc:
"""Current number of connections on the node"""

status_stats_current_connected.label:
"""Current connections"""

status_stats_initial_sessions.desc:
"""The number of sessions on the node before the evacuation/rebalance process"""

status_stats_initial_sessions.label:
"""Initial sessions"""

status_stats_current_sessions.desc:
"""Current number of sessions on the node"""

status_stats_current_sessions.label:
"""Current sessions"""

status_stats_current_disconnected_sessions.desc:
"""Current number of disconnected sessions on the node"""

status_stats_current_disconnected_sessions.label:
"""Current disconnected sessions"""

coordinator_status_donors.desc:
"""List of nodes from which connections/sessions are being evacuated"""

coordinator_status_donors.label:
"""Donors"""

coordinator_status_donor_conn_avg.desc:
"""Average number of connections per donor node"""

coordinator_status_donor_conn_avg.label:
"""Donor connections average"""

coordinator_status_donor_sess_avg.desc:
"""Average number of sessions per donor node"""

coordinator_status_donor_sess_avg.label:
"""Donor sessions average"""

coordinator_status_node.desc:
"""The node that is coordinating the evacuation/rebalance process"""

coordinator_status_node.label:
"""Coordinator node"""

evacuation_status_node.desc:
"""The node that is being evacuated"""

evacuation_status_node.label:
"""Evacuated node"""

global_status_evacuations.desc:
"""List of nodes that are being evacuated"""

global_status_evacuations.label:
"""Evacuations"""

global_status_rebalances.desc:
"""List of nodes that coordinate a rebalance"""

global_status_rebalances.label:
"""Rebalances"""

empty_response.desc:
"""The response is empty"""

empty_response.label:
"""Empty response"""

}

emqx_oracle {

  server {
    desc = "The IPv4 or IPv6 address or the hostname to connect to.<br/>"
           "A host entry has the following form: `Host[:Port]`.<br/>"
           "The Oracle Database default port 1521 is used if `[:Port]` is not specified."
    label = "Server Host"
  }

  sid {
    desc = "Sid for Oracle Database."
    label = "Oracle Database Sid"
  }

  service_name {
    desc = "Service Name for Oracle Database."
    label = "Oracle Database Service Name"
  }

}

emqx_plugins_schema {

check_interval.desc:
"""Check interval: check if the status of the plugins in the cluster is consistent, <br/>
if the results of 3 consecutive checks are not consistent, then alarm."""

enable.desc:
"""Set to 'true' to enable this plugin"""

enable.label:
"""Enable"""

install_dir.desc:
"""The installation directory for the external plugins.
The plugin beam files and configuration files should reside in
the subdirectory named as <code>emqx_foo_bar-0.1.0</code>.
<br/>
NOTE: For security reasons, this directory should **NOT** be writable
by anyone except <code>emqx</code> (or any user which runs EMQX)."""

install_dir.label:
"""Install Directory"""

name_vsn.desc:
"""The {name}-{version} of the plugin.<br/>
It should match the plugin application name-version as the for the plugin release package name<br/>
For example: my_plugin-0.1.0."""

name_vsn.label:
"""Name-Version"""

plugins.desc:
"""Manage EMQX plugins.<br/>
Plugins can be pre-built as a part of EMQX package,
or installed as a standalone package in a location specified by
<code>install_dir</code> config key<br/>
The standalone-installed plugins are referred to as 'external' plugins."""

plugins.label:
"""Plugins"""

state.desc:
"""A per-plugin config to describe the desired state of the plugin."""

state.label:
"""State"""

states.desc:
"""An array of plugins in the desired states.<br/>
The plugins are started in the defined order"""

states.label:
"""States"""

}

emqx_prometheus_api {

get_prom_conf_info.desc:
"""Get Prometheus config info"""
get_prom_conf_info.label:
"""Get Prometheus config info"""

update_prom_conf_info.desc:
"""Update Prometheus config"""
update_prom_conf_info.label:
"""Update Prometheus config"""

get_prom_data.desc:
"""Get Prometheus Data"""
get_prom_data.label:
"""Get Prometheus Data"""

}

emqx_prometheus_schema {

enable.desc:
"""Turn Prometheus data pushing on or off"""

headers.desc:
"""An HTTP Headers when pushing to Push Gateway.<br/>
For example, <code> { Authorization = "some-authz-tokens"}</code>"""

interval.desc:
"""Data reporting interval"""

job_name.desc:
"""Job Name that is pushed to the Push Gateway. Available variables:<br/>
- ${name}: Name of EMQX node.<br/>
- ${host}: Host name of EMQX node.<br/>
For example, when the EMQX node name is <code>emqx@127.0.0.1</code> then the <code>name</code> variable takes value <code>emqx</code> and the <code>host</code> variable takes value <code>127.0.0.1</code>.<br/>
Default value is: <code>${name}/instance/${name}~${host}</code>"""

mnesia_collector.desc:
"""Enable or disable Mnesia metrics collector"""

prometheus.desc:
"""EMQX's Prometheus scraping endpoint is enabled by default without authentication.
You can inspect it with a `curl` command like this: `curl -f "127.0.0.1:18083/api/v5/prometheus/stats"`<br/>
The 'enable' flag is used to turn on and off for the push-gateway integration."""

prometheus.label:
"""Prometheus"""

push_gateway_server.desc:
"""URL of Prometheus server. Pushgateway is optional, should not be configured if prometheus is to scrape EMQX."""

vm_dist_collector.desc:
"""Enable or disable VM distribution collector, collects information about the sockets and processes involved in the Erlang distribution mechanism."""

vm_memory_collector.desc:
"""Enable or disable VM memory metrics collector."""

vm_msacc_collector.desc:
"""Enable or disable VM microstate accounting metrics collector."""

vm_statistics_collector.desc:
"""Enable or disable VM statistics collector."""

vm_system_info_collector.desc:
"""Enable or disable VM system info collector."""

}

emqx_psk_schema {

chunk_size.desc:
"""The size of each chunk used to import to the built-in database from PSK file"""

enable.desc:
"""Whether to enable TLS PSK support"""

init_file.desc:
"""If init_file is specified, EMQX will import PSKs from the file into the built-in database at startup for use by the runtime.
The file has to be structured line-by-line, each line must be in the format of <code>PSKIdentity:SharedSecret</code>.
For example: <code>mydevice1:c2VjcmV0</code>"""

psk_authentication.desc:
"""PSK stands for 'Pre-Shared Keys'.
This config to enable TLS-PSK authentication.

Important! Make sure the SSL listener with only <code>tlsv1.2</code> enabled, and also PSK cipher suites
configured, such as <code>RSA-PSK-AES256-GCM-SHA384</code>.

See listener SSL options config for more details.

The IDs and secrets can be provided from a file which is configurable by the <code>init_file</code> field."""

separator.desc:
"""The separator between <code>PSKIdentity</code> and <code>SharedSecret</code> in the PSK file"""

}

emqx_redis {

cluster.desc:
"""Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode."""

cluster.label:
"""Cluster Mode"""

database.desc:
"""Redis database ID."""

database.label:
"""Database ID"""

sentinel.desc:
"""Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode."""

sentinel.label:
"""Sentinel Mode"""

sentinel_desc.desc:
"""The cluster name in Redis sentinel mode."""

sentinel_desc.label:
"""Cluster Name"""

server.desc:
"""The IPv4 or IPv6 address or the hostname to connect to.<br/>
A host entry has the following form: `Host[:Port]`.<br/>
The Redis default port 6379 is used if `[:Port]` is not specified."""

server.label:
"""Server Host"""

servers.desc:
"""A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`
For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.
A host entry has the following form: `Host[:Port]`.
The Redis default port 6379 is used if `[:Port]` is not specified."""

servers.label:
"""Servers"""

single.desc:
"""Single mode. Must be set to 'single' when Redis server is running in single mode."""

single.label:
"""Single Mode"""

}

emqx_resource_schema {

batch_size.desc:
"""Maximum batch count. If equal to 1, there's effectively no batching."""

batch_size.label:
"""Max batch size"""

batch_time.desc:
"""Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage."""

batch_time.label:
"""Max batch wait time"""

buffer_mode.desc:
"""Buffer operation mode.
<code>memory_only</mode>: Buffer all messages in memory.<code>volatile_offload</code>: Buffer message in memory first, when up to certain limit (see <code>buffer_seg_bytes</code> config for more information), then start offloading messages to disk"""

buffer_mode.label:
"""Buffer Mode"""

buffer_seg_bytes.desc:
"""Applicable when buffer mode is set to <code>volatile_offload</code>.
This value is to specify the size of each on-disk buffer file."""

buffer_seg_bytes.label:
"""Segment File Bytes"""

creation_opts.desc:
"""Creation options."""

creation_opts.label:
"""Creation Options"""

enable_batch.desc:
"""Batch mode enabled."""

enable_batch.label:
"""Enable batch"""

enable_queue.desc:
"""Enable disk buffer queue (only applicable for egress bridges).
When Enabled, messages will be buffered on disk when the bridge connection is down.
When disabled the messages are buffered in RAM only."""

enable_queue.label:
"""Enable disk buffer queue"""

health_check_interval.desc:
"""Health check interval."""

health_check_interval.label:
"""Health Check Interval"""

inflight_window.desc:
"""Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered."""

inflight_window.label:
"""Inflight window"""

max_buffer_bytes.desc:
"""Maximum number of bytes to buffer for each buffer worker."""

max_buffer_bytes.label:
"""Max buffer queue size"""

query_mode.desc:
"""Query mode. Optional 'sync/async', default 'async'."""

query_mode.label:
"""Query mode"""

request_ttl.desc:
"""Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired."""

request_ttl.label:
"""Request TTL"""

resource_opts.desc:
"""Resource options."""

resource_opts.label:
"""Resource Options"""

resume_interval.desc:
"""The interval at which the buffer worker attempts to resend failed requests in the inflight window."""

resume_interval.label:
"""Resume Interval"""

start_after_created.desc:
"""Whether start the resource right after created."""

start_after_created.label:
"""Start After Created"""

start_timeout.desc:
"""Time interval to wait for an auto-started resource to become healthy before responding resource creation requests."""

start_timeout.label:
"""Start Timeout"""

worker_pool_size.desc:
"""The number of buffer workers. Only applicable for egress type bridges.
For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0."""

worker_pool_size.label:
"""Buffer Pool Size"""

}

emqx_retainer_api {

config_content.desc:
"""The config content"""

config_not_found.desc:
"""Config not found."""

delete_matching_api.desc:
"""Delete matching messages."""
delete_matching_api.label:
"""Delete matching messages"""

from_clientid.desc:
"""The clientid of publisher."""

from_username.desc:
"""The username of publisher."""

get_config_api.desc:
"""View config"""
get_config_api.label:
"""View config"""

list_retained_api.desc:
"""List retained messages."""
list_retained_api.label:
"""List retained messages."""

lookup_api.desc:
"""Lookup a message by a topic without wildcards."""
lookup_api.label:
"""Lookup a message"""

message_detail.desc:
"""Details of the message."""

message_not_exist.desc:
"""Viewed message doesn't exist."""

msgid.desc:
"""Message ID."""

payload.desc:
"""Payload."""

publish_at.desc:
"""Message publish time, RFC 3339 format."""

qos.desc:
"""QoS."""

retained_list.desc:
"""Retained messages list."""

topic.desc:
"""Topic."""

unsupported_backend.desc:
"""Unsupported backend."""

update_config_failed.desc:
"""Update config failed"""

update_config_success.desc:
"""Update configs successfully."""

update_retainer_api.desc:
"""Update retainer config."""
update_retainer_api.label:
"""Update retainer config"""

}

emqx_retainer_schema {

backend.desc:
"""Settings for the database storing the retained messages."""

batch_deliver_limiter.desc:
"""The rate limiter name for retained messages' delivery.
Limiter helps to avoid delivering too many messages to the client at once, which may cause the client to block or crash, or drop messages due to exceeding the size of the message queue.
The names of the available rate limiters are taken from the existing rate limiters under `limiter.batch`.
If this field is empty, limiter is not used."""

batch_deliver_number.desc:
"""The number of retained messages can be delivered per batch."""

batch_read_number.desc:
"""Size of the batch when reading messages from storage. 0 means no limit."""

enable.desc:
"""Enable retainer feature"""

flow_control.desc:
"""Flow control."""

max_payload_size.desc:
"""Maximum retained message size."""

max_retained_messages.desc:
"""Maximum number of retained messages. 0 means no limit."""

mnesia_config_storage_type.desc:
"""Specifies whether the messages are stored in RAM or persisted on disc."""

mnesia_config_type.desc:
"""Backend type."""

msg_clear_interval.desc:
"""Interval for EMQX to scan expired messages and delete them. Never scan if the value is 0."""

msg_expiry_interval.desc:
"""Message retention time. This config is only applicable for messages without the Message Expiry Interval message property.
0 means message will never expire."""

stop_publish_clear_msg.desc:
"""When the retained flag of the `PUBLISH` message is set and Payload is empty,
whether to continue to publish the message.
See:
http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038"""

delivery_rate.desc:
"""The maximum rate of delivering retained messages"""
}

emqx_rewrite_api {

list_topic_rewrite_api.desc:
"""List all rewrite rules"""
list_topic_rewrite_api.label:
"""List all rewrite rules"""

update_topic_rewrite_api.desc:
"""Update all rewrite rules"""
update_topic_rewrite_api.label:
"""Update all rewrite rules"""

update_topic_rewrite_api_response413.desc:
"""Rules count exceed max limit"""
update_topic_rewrite_api_response413.label:
"""Rules count exceed limit"""

}

emqx_rule_api_schema {

event_action.desc:
"""Publish or Subscribe"""

event_action.label:
"""Publish or Subscribe"""

event_payload.desc:
"""The Message Payload"""

event_payload.label:
"""Message Payload"""

metrics_actions_failed_out_of_service.desc:
"""How many times the rule has failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped."""

metrics_actions_failed_out_of_service.label:
"""Fail Action"""

metrics_actions_failed_unknown.desc:
"""The number of action failures that have occurred due to unanticipated reasons. For more information on these errors, please refer to the EMQX log file."""

metrics_actions_failed_unknown.label:
"""Unknown Failures"""

event_server.desc:
"""The IP address (or hostname) and port of the MQTT broker, in IP:Port format"""

event_server.label:
"""Server IP And Port"""

metrics_actions_total.desc:
"""How many times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule."""

metrics_actions_total.label:
"""Action Total"""

event_ctx_disconnected_da.desc:
"""The Time that this Client is Disconnected"""

event_ctx_disconnected_da.label:
"""Disconnected Time"""

event_topic.desc:
"""Message Topic"""

event_topic.label:
"""Message Topic"""

event_peername.desc:
"""The IP Address and Port of the Peer Client"""

event_peername.label:
"""IP Address And Port"""

metrics_sql_passed.desc:
"""How many times the SQL is passed"""

metrics_sql_passed.label:
"""SQL Passed"""

test_context.desc:
"""The context of the event for testing"""

test_context.label:
"""Event Conetxt"""

node_node.desc:
"""The node name"""

node_node.label:
"""Node Name"""

event_from_clientid.desc:
"""The Client ID"""

event_from_clientid.label:
"""Client ID"""

event_keepalive.desc:
"""KeepAlive"""

event_keepalive.label:
"""KeepAlive"""

event_connected_at.desc:
"""The Time that this Client is Connected"""

event_connected_at.label:
"""Connected Time"""

metrics_sql_failed_exception.desc:
"""How many times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables"""

metrics_sql_failed_exception.label:
"""SQL Exception"""

event_from_username.desc:
"""The User Name"""

event_from_username.label:
"""Username"""

event_ctx_connack_reason_code.desc:
"""The reason code"""

event_ctx_connack_reason_code.label:
"""Reason Code"""

rs_description.desc:
"""The description"""

rs_description.label:
"""Description"""

rule_id.desc:
"""The ID of the rule"""

rule_id.label:
"""Rule ID"""

rs_event.desc:
"""The event topics"""

rs_event.label:
"""Event Topics"""

root_rule_engine.desc:
"""Rule engine configurations. This API can be used to change EMQX rule engine settings. But not for the rules. To list, create, or update rules, call the '/rules' API instead."""

root_rule_engine.label:
"""Rule engine configuration"""

event_sockname.desc:
"""The IP Address and Port of the Local Listener"""

event_sockname.label:
"""IP Address And Port"""

event_qos.desc:
"""The Message QoS"""

event_qos.label:
"""Message QoS"""

event_mountpoint.desc:
"""The Mountpoint"""

event_mountpoint.label:
"""Mountpoint"""

rs_title.desc:
"""The title"""

rs_title.label:
"""Title"""

ri_metrics.desc:
"""The metrics of the rule"""

ri_metrics.label:
"""Rule Metrics"""

event_retain.desc:
"""If is a retain message"""

event_retain.label:
"""Retain Message"""

event_event_type.desc:
"""Event Type"""

event_event_type.label:
"""Event Type"""

event_expiry_interval.desc:
"""Expiry Interval"""

event_expiry_interval.label:
"""Expiry Interval"""

metrics_sql_matched.desc:
"""How many times the FROM clause of the SQL is matched."""

metrics_sql_matched.label:
"""Matched"""

event_clientid.desc:
"""The Client ID"""

event_clientid.label:
"""Client ID"""

metrics_actions_success.desc:
"""How many times the rule successided to call the actions."""

metrics_actions_success.label:
"""Success Action"""

metrics_actions_failed.desc:
"""How many times the rule failed to call the actions."""

metrics_actions_failed.label:
"""Failed Action"""

metrics_sql_matched_rate.desc:
"""The rate of matched, times/second"""

metrics_sql_matched_rate.label:
"""命中速率"""

event_proto_ver.desc:
"""Protocol Version"""

event_proto_ver.label:
"""Protocol Version"""

event_publish_received_at.desc:
"""The Time that this Message is Received"""

event_publish_received_at.label:
"""Message Received Time"""

metrics_sql_matched_rate_last5m.desc:
"""The average rate of matched in last 5 minutes, times/second"""

metrics_sql_matched_rate_last5m.label:
"""Average Matched Rate"""

event_is_bridge.desc:
"""Is Bridge"""

event_is_bridge.label:
"""Is Bridge"""

event_authz_source.desc:
"""Cache, Plugs or Default"""

event_authz_source.label:
"""Auth Source"""

metrics_sql_failed_unknown.desc:
"""How many times the SQL is failed due to an unknown error."""

metrics_sql_failed_unknown.label:
"""SQL Unknown Error"""

metrics_sql_failed.desc:
"""How many times the SQL statement has failed"""

metrics_sql_failed.label:
"""SQL Failed"""

event_ctx_dropped.desc:
"""The Reason for Dropping"""

event_ctx_dropped.label:
"""Dropped Reason"""

root_rule_test.desc:
"""Schema for testing rules"""

root_rule_test.label:
"""Rule Test Schema"""

rs_test_columns.desc:
"""The test columns"""

rs_test_columns.label:
"""Test Columns"""

event_peerhost.desc:
"""The IP Address of the Peer Client"""

event_peerhost.label:
"""Peer IP Address"""

event_proto_name.desc:
"""Protocol Name"""

event_proto_name.label:
"""Protocol Name"""

root_rule_events.desc:
"""Schema for rule events"""

root_rule_events.label:
"""Rule Events Schema"""

rs_sql_example.desc:
"""The sql_example"""

rs_sql_example.label:
"""SQL Example"""

metrics_sql_matched_rate_max.desc:
"""The max rate of matched, times/second"""

metrics_sql_matched_rate_max.label:
"""Max Matched Rate"""

event_clean_start.desc:
"""Clean Start"""

event_clean_start.label:
"""Clean Start"""

ri_created_at.desc:
"""The created time of the rule"""

ri_created_at.label:
"""Rule Create Time"""

event_dup.desc:
"""The DUP flag of the MQTT message"""

event_dup.label:
"""DUP Flag"""

ri_from.desc:
"""The topics of the rule"""

ri_from.label:
"""Topics of Rule"""

ri_node_metrics.desc:
"""The metrics of the rule for each node"""

ri_node_metrics.label:
"""Each Node Rule Metrics"""

root_rule_creation.desc:
"""Schema for creating rules"""

root_rule_creation.label:
"""Create Schema"""

event_result.desc:
"""Allow or Deny"""

event_result.label:
"""Auth Result"""

event_id.desc:
"""Message ID"""

event_id.label:
"""Message ID"""

event_username.desc:
"""Username"""

event_username.label:
"""Username"""

root_rule_info.desc:
"""Schema for rule info"""

root_rule_info.label:
"""Info Schema"""

rs_columns.desc:
"""The columns"""

rs_columns.label:
"""Column"""

test_sql.desc:
"""The SQL of the rule for testing"""

test_sql.label:
"""Test SQL"""

event_ctx_disconnected_reason.desc:
"""The Reason for Disconnect"""

event_ctx_disconnected_reason.label:
"""Disconnect Reason"""

}

emqx_rule_engine_api {

api1.desc:
"""List all rules"""

api1.label:
"""List All Rules"""

api10.desc:
"""Update rule engine configuration."""

api10.label:
"""Update configuration"""

api1_enable.desc:
"""Filter enable/disable rules"""

api1_from.desc:
"""Filter rules by from(topic), exact match"""

api1_like_description.desc:
"""Filter rules by description, Substring matching"""

api1_like_from.desc:
"""Filter rules by from(topic), Substring matching"""

api1_like_id.desc:
"""Filter rules by id, Substring matching"""

api1_match_from.desc:
"""Filter rules by from(topic), Mqtt topic matching"""

api1_resp.desc:
"""List of rules"""

api1_resp.label:
"""List Rules"""

api2.desc:
"""Create a new rule using given Id"""

api2.label:
"""Create Rule By ID"""

api3.desc:
"""List all events can be used in rules"""

api3.label:
"""List All Events Can Be Used In Rule"""

api4.desc:
"""Get a rule by given Id"""

api4.label:
"""Get Rule"""

api4_1.desc:
"""Get a rule's metrics by given Id"""

api4_1.label:
"""Get Metric"""

api5.desc:
"""Update a rule by given Id to all nodes in the cluster"""

api5.label:
"""Update Cluster Rule"""

api6.desc:
"""Delete a rule by given Id from all nodes in the cluster"""

api6.label:
"""Delete Cluster Rule"""

api7.desc:
"""Reset a rule metrics"""

api7.label:
"""Reset Rule Metrics"""

api8.desc:
"""Test a rule"""

api8.label:
"""Test Rule"""

api9.desc:
"""Get rule engine configuration."""

api9.label:
"""Get configuration"""

}

emqx_rule_engine_schema {

console_function.desc:
"""Print the actions to the console"""

console_function.label:
"""Console Function"""

desc_builtin_action_console.desc:
"""Configuration for a built-in action."""

desc_builtin_action_console.label:
"""Action Console Configuration"""

desc_builtin_action_republish.desc:
"""Configuration for a built-in action."""

desc_builtin_action_republish.label:
"""Republish Configuration"""

desc_republish_args.desc:
"""The arguments of the built-in 'republish' action.One can use variables in the args.
The variables are selected by the rule. For example, if the rule SQL is defined as following:
<code>
    SELECT clientid, qos, payload FROM "t/1"
</code>
Then there are 3 variables available: <code>clientid</code>, <code>qos</code> and
<code>payload</code>. And if we've set the args to:
<code>
    {
        topic = "t/${clientid}"
        qos = "${qos}"
        payload = "msg: ${payload}"
    }
</code>
When the rule is triggered by an MQTT message with payload = `hello`, qos = 1,
clientid = `Steve`, the rule will republish a new MQTT message to topic `t/Steve`,
payload = `msg: hello`, and `qos = 1`."""

desc_republish_args.label:
"""Republish Args"""

desc_rule_engine.desc:
"""Configuration for the EMQX Rule Engine."""

desc_rule_engine.label:
"""Rule Engine Configuration"""

desc_rules.desc:
"""Configuration for a rule."""

desc_rules.label:
"""Rule Configuration"""

desc_user_provided_function.desc:
"""Configuration for a built-in action."""

desc_user_provided_function.label:
"""User Provid Function Configuration"""

republish_args_payload.desc:
"""The payload of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${payload}. If variable ${payload} is not found from the selected result
of the rule, then the string "undefined" is used."""

republish_args_payload.label:
"""Message Payload"""

republish_args_qos.desc:
"""The qos of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,
0 is used."""

republish_args_qos.label:
"""Message QoS"""

republish_args_retain.desc:
"""The 'retain' flag of the message to be re-published.
Template with variables is allowed, see description of the 'republish_args'.
Defaults to ${retain}. If variable ${retain} is not found from the selected result
of the rule, false is used."""

republish_args_retain.label:
"""Retain Flag"""

republish_args_topic.desc:
"""The target topic of message to be re-published.
Template with variables is allowed, see description of the 'republish_args'."""

republish_args_topic.label:
"""Target Topic"""

republish_args_user_properties.desc:
"""From which variable should the MQTT message's User-Property pairs be taken from.
The value must be a map.
You may configure it to <code>${pub_props.'User-Property'}</code> or
use <code>SELECT *,pub_props.'User-Property' as user_properties</code>
to forward the original user properties to the republished message.
You may also call <code>map_put</code> function like
<code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code>
to inject user properties.
NOTE: MQTT spec allows duplicated user property names, but EMQX Rule-Engine does not."""

republish_function.desc:
"""Republish the message as a new MQTT message"""

republish_function.label:
"""Republish Function"""

rule_engine_ignore_sys_message.desc:
"""When set to 'true' (default), rule-engine will ignore messages published to $SYS topics."""

rule_engine_ignore_sys_message.label:
"""Ignore Sys Message"""

rule_engine_jq_function_default_timeout.desc:
"""Default timeout for the `jq` rule engine function"""

rule_engine_jq_function_default_timeout.label:
"""Rule engine jq function default timeout"""

rule_engine_jq_implementation_module.desc:
"""The implementation module for the jq rule engine function. The two options are jq_nif and jq_port. With the jq_nif option an Erlang NIF library is used while with the jq_port option an implementation based on Erlang port programs is used. The jq_nif option (the default option) is the fastest implementation of the two but jq_port is safer as the jq programs will not execute in the same process as the Erlang VM."""

rule_engine_jq_implementation_module.label:
"""JQ Implementation Module"""

rule_engine_rules.desc:
"""The rules"""

rule_engine_rules.label:
"""Rules"""

rules_actions.desc:
"""A list of actions of the rule.
An action can be a string that refers to the channel ID of an EMQX bridge, or an object
that refers to a function.
There a some built-in functions like "republish" and "console", and we also support user
provided functions in the format: "{module}:{function}".
The actions in the list are executed sequentially.
This means that if one of the action is executing slowly, all the following actions will not
be executed until it returns.
If one of the action crashed, all other actions come after it will still be executed, in the
original order.
If there's any error when running an action, there will be an error message, and the 'failure'
counter of the function action or the bridge channel will increase."""

rules_actions.label:
"""Rule Action List"""

rules_description.desc:
"""The description of the rule"""

rules_description.label:
"""Rule Description"""

rules_enable.desc:
"""Enable or disable the rule"""

rules_enable.label:
"""Enable Or Disable Rule"""

rules_metadata.desc:
"""Rule metadata, do not change manually"""

rules_metadata.label:
"""Rule metadata"""

rules_name.desc:
"""The name of the rule"""

rules_name.label:
"""Rule Name"""

rules_sql.desc:
"""SQL query to transform the messages.
Example: <code>SELECT * FROM "test/topic" WHERE payload.x = 1</code>"""

rules_sql.label:
"""Rule SQL"""

user_provided_function_args.desc:
"""The args will be passed as the 3rd argument to module:function/3,
checkout the function <code>console</code> and <code>republish</code> in the source file:
<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example."""

user_provided_function_args.label:
"""User Provided Function Args"""

user_provided_function_function.desc:
"""The user provided function. Should be in the format: '{module}:{function}'.
Where {module} is the Erlang callback module and {function} is the Erlang function.

To write your own function, checkout the function <code>console</code> and
<code>republish</code> in the source file:
<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example."""

user_provided_function_function.label:
"""User Provided Function"""

}

emqx_s3_schema {

access_key_id.desc:
"""The access key ID of the S3 bucket."""

secret_access_key.desc:
"""The secret access key of the S3 bucket."""

bucket.desc:
"""The name of the S3 bucket."""

host.desc:
"""The host of the S3 endpoint."""

port.desc:
"""The port of the S3 endpoint."""

url_expire_time.desc:
"""The time in seconds for which the signed URLs to the S3 objects are valid."""

min_part_size.desc:
"""The minimum part size for multipart uploads.<br/>
Uploaded data will be accumulated in memory until this size is reached."""

max_part_size.desc:
"""The maximum part size for multipart uploads.<br/>
S3 uploader won't try to upload parts larger than this size."""

acl.desc:
"""The ACL to use for the uploaded objects."""

transport_options.desc:
"""Options for the HTTP transport layer used by the S3 client."""

ipv6_probe.desc:
"""Whether to probe for IPv6 support."""

}

emqx_schema {

fields_mqtt_quic_listener_peer_unidi_stream_count.desc:
"""Number of unidirectional streams to allow the peer to open."""

fields_mqtt_quic_listener_peer_unidi_stream_count.label:
"""Peer unidi stream count"""

fields_authorization_no_match.desc:
"""Default access control action if the user or client matches no ACL rules,
or if no such user or client is found by the configurable authorization
sources such as built_in_database, an HTTP API, or a query against PostgreSQL.
Find more details in 'authorization.sources' config."""

fields_authorization_no_match.label:
"""Authorization no match"""

sysmon_top_db_hostname.desc:
"""Hostname of the PostgreSQL database that collects the data points"""

sysmon_top_db_hostname.label:
"""DB Hostname"""

zones.desc:
"""A zone is a set of configs grouped by the zone <code>name</code>.
For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.
NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted."""

fields_mqtt_quic_listener_certfile.desc:
"""Path to the certificate file. Will be deprecated in 5.1, use .ssl_options.certfile instead."""

fields_mqtt_quic_listener_certfile.label:
"""Certificate file"""

fields_rate_limit_conn_bytes_in.desc:
"""Limit the rate of receiving packets for a MQTT connection.
The rate is counted by bytes of packets per second."""

fields_rate_limit_conn_bytes_in.label:
"""Connection bytes in"""

crl_cache_capacity.desc:
"""The maximum number of CRL URLs that can be held in cache.  If the cache is at full capacity and a new URL must be fetched, then it'll evict the oldest inserted URL in the cache."""

crl_cache_capacity.label:
"""CRL Cache Capacity"""

alarm_actions.desc:
"""The actions triggered when the alarm is activated.<br/>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.
<code>log</code> is to write the alarm to log (console or file).
<code>publish</code> is to publish the alarm as an MQTT message to the system topics:
<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and
<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"""

alarm_actions.label:
"""Alarm Actions"""

base_listener_max_connections.desc:
"""The maximum number of concurrent connections allowed by the listener."""

base_listener_max_connections.label:
"""Max connections"""

mqtt_peer_cert_as_username.desc:
"""Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: CN field of the certificate
- <code>dn</code>: DN field of the certificate
- <code>crt</code>: Content of the <code>DER</code> or <code>PEM</code> certificate
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Username
- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate"""

mqtt_peer_cert_as_username.label:
"""Use Peer Certificate as Username"""

fields_cache_enable.desc:
"""Enable or disable the authorization cache."""

fields_cache_enable.label:
"""Enable or disable the authorization cache."""

fields_mqtt_quic_listener_disconnect_timeout_ms.desc:
"""How long to wait for an ACK before declaring a path dead and disconnecting. Default: 16000"""

fields_mqtt_quic_listener_disconnect_timeout_ms.label:
"""Disconnect timeout ms"""

mqtt_max_topic_alias.desc:
"""Maximum topic alias, 0 means no topic alias supported."""

mqtt_max_topic_alias.label:
"""Max Topic Alias"""

common_ssl_opts_schema_user_lookup_fun.desc:
"""EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>
Has no effect when TLS version is configured (or negotiated) to 1.3"""

common_ssl_opts_schema_user_lookup_fun.label:
"""SSL PSK user lookup fun"""

fields_listeners_wss.desc:
"""HTTPS websocket listeners."""

fields_listeners_wss.label:
"""HTTPS websocket listeners"""

sysmon_top_max_procs.desc:
"""Stop collecting data when the number of processes
in the VM exceeds this value"""

sysmon_top_max_procs.label:
"""Max procs"""

mqtt_use_username_as_clientid.desc:
"""Whether to use Username as Client ID.
This setting takes effect later than <code>Use Peer Certificate as Username</code> and <code>Use peer certificate as Client ID</code>."""

mqtt_use_username_as_clientid.label:
"""Use Username as Client ID"""

mqtt_max_qos_allowed.desc:
"""Maximum QoS allowed."""

mqtt_max_qos_allowed.label:
"""Max QoS"""

fields_mqtt_quic_listener_max_binding_stateless_operations.desc:
"""The maximum number of stateless operations that may be queued on a binding at any one time. Default: 100"""

fields_mqtt_quic_listener_max_binding_stateless_operations.label:
"""Max binding stateless operations"""

fields_mqtt_quic_listener_stream_recv_buffer_default.desc:
"""Stream initial buffer size. Default: 4096"""

fields_mqtt_quic_listener_stream_recv_buffer_default.label:
"""Stream recv buffer default"""

fields_mqtt_quic_listener_pacing_enabled.desc:
"""Pace sending to avoid overfilling buffers on the path. Default: 1 (Enabled)"""

fields_mqtt_quic_listener_pacing_enabled.label:
"""Pacing enabled"""

mqtt_max_subscriptions.desc:
"""Maximum number of subscriptions allowed per client."""

mqtt_max_subscriptions.label:
"""Max Subscriptions"""

persistent_session_builtin_messages_table.desc:
"""Performance tuning options for built-in messages table."""

persistent_session_builtin_messages_table.label:
"""Persistent messages"""

sysmon_os_cpu_low_watermark.desc:
"""The threshold, as percentage of system CPU load,
 for how much system cpu can be used before the corresponding alarm is cleared."""

sysmon_os_cpu_low_watermark.label:
"""CPU low watermark"""

fields_mqtt_quic_listener_tls_server_max_send_buffer.desc:
"""How much Server TLS data to buffer. Default: 8192"""

fields_mqtt_quic_listener_tls_server_max_send_buffer.label:
"""TLS server max send buffer"""

base_listener_bind.desc:
"""IP address and port for the listening socket."""

base_listener_bind.label:
"""IP address and port"""

server_ssl_opts_schema_handshake_timeout.desc:
"""Maximum time duration allowed for the handshake to complete"""

server_ssl_opts_schema_handshake_timeout.label:
"""Handshake timeout"""

fields_deflate_opts_server_context_takeover.desc:
"""Takeover means the compression state is retained between server messages."""

fields_deflate_opts_server_context_takeover.label:
"""Server context takeover"""

mqtt_session_expiry_interval.desc:
"""Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections."""

mqtt_session_expiry_interval.label:
"""Session Expiry Interval"""

fields_listener_enabled.desc:
"""Enable listener."""

fields_listener_enabled.label:
"""Enable listener"""

mqtt.desc:
"""Global MQTT configuration.
The configs here work as default values which can be overridden in <code>zone</code> configs"""

crl_cache_refresh_http_timeout.desc:
"""The timeout for the HTTP request when fetching CRLs.  This is a global setting for all listeners."""

crl_cache_refresh_http_timeout.label:
"""CRL Cache Refresh HTTP Timeout"""

fields_tcp_opts_backlog.desc:
"""TCP backlog defines the maximum length that the queue of
pending connections can grow to."""

fields_tcp_opts_backlog.label:
"""TCP backlog length"""

fields_mqtt_quic_listener_initial_window_packets.desc:
"""The size (in packets) of the initial congestion window for a connection. Default: 10"""

fields_mqtt_quic_listener_initial_window_packets.label:
"""Initial window packets"""

flapping_detect_enable.desc:
"""Enable flapping connection detection feature."""

flapping_detect_enable.label:
"""Enable flapping detection"""

sysmon_top_db_password.desc:
"""EMQX user password in the PostgreSQL database"""

sysmon_top_db_password.label:
"""DB Password"""

fields_ws_opts_check_origins.desc:
"""List of allowed origins.<br/>See <code>check_origin_enable</code>."""

fields_ws_opts_check_origins.label:
"""Allowed origins"""

fields_deflate_opts_client_context_takeover.desc:
"""Takeover means the compression state is retained between client messages."""

fields_deflate_opts_client_context_takeover.label:
"""Client context takeover"""

base_listener_acceptors.desc:
"""The size of the listener's receiving pool."""

base_listener_acceptors.label:
"""Acceptors Num"""

common_ssl_opts_schema_cacertfile.desc:
"""Trusted PEM format CA certificates bundle file.<br/>
The certificates in this file are used to verify the TLS peer's certificates.
Append new certificates to the file if new CAs are to be trusted.
There is no need to restart EMQX to have the updated file loaded, because
the system regularly checks if file has been updated (and reload).<br/>
NOTE: invalidating (deleting) a certificate from the file will not affect
already established connections."""

common_ssl_opts_schema_cacertfile.label:
"""CACertfile"""

fields_ws_opts_mqtt_path.desc:
"""WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:
<code>ws://{ip}:{port}/mqtt</code>"""

fields_ws_opts_mqtt_path.label:
"""WS MQTT Path"""

sysmon_os_procmem_high_watermark.desc:
"""The threshold, as percentage of system memory,
 for how much system memory can be allocated by one Erlang process before
 the corresponding alarm is raised."""

sysmon_os_procmem_high_watermark.label:
"""ProcMem high wartermark"""

fields_listeners_quic.desc:
"""QUIC listeners."""

fields_listeners_quic.label:
"""QUIC listeners"""

fields_listeners_ws.desc:
"""HTTP websocket listeners."""

fields_listeners_ws.label:
"""HTTP websocket listeners"""

mqtt_retry_interval.desc:
"""Retry interval for QoS 1/2 message delivering."""

mqtt_retry_interval.label:
"""Retry Interval"""

stats_enable.desc:
"""Enable/disable statistic data collection."""

stats_enable.label:
"""Enable/disable statistic data collection."""

fields_authorization_deny_action.desc:
"""The action when the authorization check rejects an operation."""

fields_authorization_deny_action.label:
"""Authorization deny action"""

fields_deflate_opts_server_max_window_bits.desc:
"""Specifies the size of the compression context for the server."""

fields_deflate_opts_server_max_window_bits.label:
"""Server compression max window size"""

client_ssl_opts_schema_server_name_indication.desc:
"""Specify the host name to be used in TLS Server Name Indication extension.<br/>
For instance, when connecting to "server.example.net", the genuine server
which accepts the connection and performs TLS handshake may differ from the
host the TLS client initially connects to, e.g. when connecting to an IP address
or when the host has multiple resolvable DNS records <br/>
If not specified, it will default to the host name string which is used
to establish the connection, unless it is IP addressed used.<br/>
The host name is then also used in the host name verification of the peer
certificate.<br/> The special value 'disable' prevents the Server Name
Indication extension from being sent and disables the hostname
verification check."""

client_ssl_opts_schema_server_name_indication.label:
"""Server Name Indication"""

fields_mqtt_quic_listener_retry_memory_limit.desc:
"""The percentage of available memory usable for handshake connections before stateless retry is used. Calculated as `N/65535`. Default: 65"""

fields_mqtt_quic_listener_retry_memory_limit.label:
"""Retry memory limit"""

force_shutdown_max_mailbox_size.desc:
"""In EMQX, each online client corresponds to an individual Erlang process. The configuration value establishes a mailbox size limit for these processes. If the mailbox size surpasses this limit, the client will be automatically terminated."""

force_shutdown_max_mailbox_size.label:
"""Maximum mailbox size."""

sys_heartbeat_interval.desc:
"""Time interval for publishing following heartbeat messages:
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`"""

flapping_detect_ban_time.desc:
"""How long the flapping clientid will be banned."""

flapping_detect_ban_time.label:
"""Ban time"""

sysmon_top_num_items.desc:
"""The number of top processes per monitoring group"""

sysmon_top_num_items.label:
"""Top num items"""

persistent_session_builtin_session_table.desc:
"""Performance tuning options for built-in session table."""

persistent_session_builtin_session_table.label:
"""Persistent session"""

mqtt_upgrade_qos.desc:
"""Force upgrade of QoS level according to subscription."""

mqtt_upgrade_qos.label:
"""Upgrade QoS"""

mqtt_shared_subscription.desc:
"""Whether to enable support for MQTT shared subscription."""

mqtt_shared_subscription.label:
"""Shared Subscription Available"""

fields_tcp_opts_sndbuf.desc:
"""The TCP send buffer (OS kernel) for the connections."""

fields_tcp_opts_sndbuf.label:
"""TCP send buffer"""

sysmon_os_mem_check_interval.desc:
"""The time interval for the periodic memory check."""

sysmon_os_mem_check_interval.label:
"""Mem check interval"""

server_ssl_opts_schema_gc_after_handshake.desc:
"""Memory usage tuning. If enabled, will immediately perform a garbage collection after the TLS/SSL handshake."""

server_ssl_opts_schema_gc_after_handshake.label:
"""Perform GC after handshake"""

fields_mqtt_quic_listener_ssl_options.desc:
"""TLS options for QUIC transport"""

fields_mqtt_quic_listener_ssl_options.label:
"""TLS Options"""

fields_ws_opts_mqtt_piggyback.desc:
"""Whether a WebSocket message is allowed to contain multiple MQTT packets."""

fields_ws_opts_mqtt_piggyback.label:
"""MQTT Piggyback"""

base_listener_mountpoint.desc:
"""When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message
is delivered to the subscriber. The mountpoint is a way that users can use
to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.\<name>.mountpoint`
set to `some_tenant`, then the client actually subscribes to the topic
`some_tenant/t`. Similarly, if another client B (connected to the same listener
as the client A) sends a message to topic `t`, the message is routed
to all the clients subscribed `some_tenant/t`, so client A will receive the
message, with topic name `t`.<br/>
Set to `""` to disable the feature.<br/>

Variables in mountpoint string:
  - <code>${clientid}</code>: clientid
  - <code>${username}</code>: username"""

base_listener_mountpoint.label:
"""mountpoint"""

mqtt_max_awaiting_rel.desc:
"""For each publisher session, the maximum number of outstanding QoS 2 messages pending on the client to send PUBREL. After reaching this limit, new QoS 2 PUBLISH requests will be rejected with `147(0x93)` until either PUBREL is received or timed out."""

mqtt_max_awaiting_rel.label:
"""Max Awaiting PUBREL"""

ciphers_schema_quic.desc:
"""This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
<br/>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.<br/>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
<br/>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br/>

NOTE: QUIC listener supports only 'tlsv1.3' ciphers"""

ciphers_schema_quic.label:
""""""

fields_mqtt_quic_listener_max_bytes_per_key.desc:
"""Maximum number of bytes to encrypt with a single 1-RTT encryption key before initiating key update. Default: 274877906944"""

fields_mqtt_quic_listener_max_bytes_per_key.label:
"""Max bytes per key"""

fields_mqtt_quic_listener_mtu_discovery_search_complete_timeout_us.desc:
"""The time in microseconds to wait before reattempting MTU probing if max was not reached. Default: 600000000"""

fields_mqtt_quic_listener_mtu_discovery_search_complete_timeout_us.label:
"""MTU discovery search complete timeout us"""

fields_ws_opts_check_origin_enable.desc:
"""If <code>true</code>, <code>origin</code> HTTP header will be
 validated against the list of allowed origins configured in <code>check_origins</code>
 parameter."""

fields_ws_opts_check_origin_enable.label:
"""Check origin"""

sysmon_vm_busy_dist_port.desc:
"""When the RPC connection used to communicate with other nodes in the cluster is overloaded,
there will be a <code>busy_dist_port</code> warning log,
and an MQTT message is published to system topic <code>$SYS/sysmon/busy_dist_port</code>."""

sysmon_vm_busy_dist_port.label:
"""Enable Busy Distribution Port monitoring."""

mqtt_max_mqueue_len.desc:
"""Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full."""

mqtt_max_mqueue_len.label:
"""Max Message Queue Length"""

mqtt_max_inflight.desc:
"""Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment."""

mqtt_max_inflight.label:
"""Max Inflight"""

persistent_session_store_enabled.desc:
"""Use the database to store information about persistent sessions.
This makes it possible to migrate a client connection to another
cluster node if a node is stopped."""

persistent_session_store_enabled.label:
"""Enable persistent session store"""

fields_deflate_opts_level.desc:
"""Compression level."""

fields_deflate_opts_level.label:
"""Compression level"""

mqtt_server_keepalive.desc:
"""The keep alive duration required by EMQX. To use the setting from the client side, choose disabled from the drop-down list. Only applicable to MQTT 5.0 clients."""

mqtt_server_keepalive.label:
"""Server Keep Alive"""

global_authentication.desc:
"""Default authentication configs for all MQTT listeners.

For per-listener overrides see <code>authentication</code> in listener configs

This option can be configured with:
<ul>
  <li><code>[]</code>: The default value, it allows *ALL* logins</li>
  <li>one: For example <code>{enable:true,backend:"built_in_database",mechanism="password_based"}</code></li>
  <li>chain: An array of structs.</li>
</ul>

When a chain is configured, the login credentials are checked against the backends per the configured order, until an 'allow' or 'deny' decision can be made.

If there is no decision after a full chain exhaustion, the login is rejected."""

fields_mqtt_quic_listener_load_balancing_mode.desc:
"""0: Disabled, 1: SERVER_ID_IP, 2: SERVER_ID_FIXED. default: 0"""

fields_mqtt_quic_listener_load_balancing_mode.label:
"""Load balancing mode"""

persistent_session_store_session_message_gc_interval.desc:
"""The starting interval for garbage collection of transient data for
persistent session messages. This does not affect the lifetime length
of persistent session messages."""

persistent_session_store_session_message_gc_interval.label:
"""Session message GC interval"""

server_ssl_opts_schema_ocsp_refresh_http_timeout.desc:
"""The timeout for the HTTP request when checking OCSP responses."""

server_ssl_opts_schema_ocsp_refresh_http_timeout.label:
"""OCSP Refresh HTTP Timeout"""

fields_tcp_opts_send_timeout.desc:
"""The TCP send timeout for the connections."""

fields_tcp_opts_send_timeout.label:
"""TCP send timeout"""

sysmon_vm_process_high_watermark.desc:
"""The threshold, as percentage of processes, for how many
 processes can simultaneously exist at the local node before the corresponding
 alarm is raised."""

sysmon_vm_process_high_watermark.label:
"""Process high watermark"""

fields_tcp_opts_buffer.desc:
"""The size of the user-space buffer used by the driver."""

fields_tcp_opts_buffer.label:
"""TCP user-space buffer"""

server_ssl_opts_schema_honor_cipher_order.desc:
"""An important security setting, it forces the cipher to be set based
 on the server-specified order instead of the client-specified order,
 hence enforcing the (usually more properly configured) security
 ordering of the server administrator."""

server_ssl_opts_schema_honor_cipher_order.label:
"""SSL honor cipher order"""

conn_congestion_min_alarm_sustain_duration.desc:
"""Minimal time before clearing the alarm.<br/>The alarm is cleared only when there's no pending data in<br/>the queue, and at least <code>min_alarm_sustain_duration</code>milliseconds passed since the last time we considered the connection 'congested'.<br/>This is to avoid clearing and raising the alarm again too often."""

conn_congestion_min_alarm_sustain_duration.label:
"""Sustain duration"""

fields_mqtt_quic_listener_keep_alive_interval_ms.desc:
"""How often to send PING frames to keep a connection alive."""

fields_mqtt_quic_listener_keep_alive_interval_ms.label:
"""Keep alive interval ms"""

fields_mqtt_quic_listener_handshake_idle_timeout_ms.desc:
"""How long a handshake can idle before it is discarded"""

fields_mqtt_quic_listener_handshake_idle_timeout_ms.label:
"""Handshake idle timeout ms"""

broker_session_locking_strategy.desc:
"""Session locking strategy in a cluster.
  - `local`: only lock the session on the current node
  - `one`: select only one remote node to lock the session
  - `quorum`: select some nodes to lock the session
  - `all`: lock the session on all the nodes in the cluster"""

persistent_store_ram_cache.desc:
"""Maintain a copy of the data in RAM for faster access."""

persistent_store_ram_cache.label:
"""RAM cache"""

fields_mqtt_quic_listener_stream_recv_window_default.desc:
"""Initial stream receive window size. Default: 32678"""

fields_mqtt_quic_listener_stream_recv_window_default.label:
"""Stream recv window default"""

mqtt_mqueue_priorities.desc:
"""Topic priorities. Priority number [1-255]
There's no priority table by default, hence all messages are treated equal.

**NOTE**: Comma and equal signs are not allowed for priority topic names.
**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.

**Examples**:
To configure <code>"topic/1" > "topic/2"</code>:
<code>mqueue_priorities: {"topic/1": 10, "topic/2": 8}</code>"""

mqtt_mqueue_priorities.label:
"""Topic Priorities"""

fields_rate_limit_conn_messages_in.desc:
"""Message limit for the external MQTT connections."""

fields_rate_limit_conn_messages_in.label:
"""connecting messages in"""

fields_rate_limit_max_conn_rate.desc:
"""Maximum connections per second."""

fields_rate_limit_max_conn_rate.label:
"""Max connection rate"""

alarm_size_limit.desc:
"""The maximum total number of deactivated alarms to keep as history.<br/>When this limit is exceeded, the oldest deactivated alarms are deleted to cap the total number."""

alarm_size_limit.label:
"""Alarm size limit"""

fields_cache_max_size.desc:
"""Maximum number of cached items."""

fields_cache_max_size.label:
"""Maximum number of cached items."""

fields_listeners_tcp.desc:
"""TCP listeners."""

fields_listeners_tcp.label:
"""TCP listeners"""

conn_congestion_enable_alarm.desc:
"""Enable or disable connection congestion alarm."""

conn_congestion_enable_alarm.label:
"""Enable/disable congestion alarm"""

fields_ws_opts_proxy_port_header.desc:
"""HTTP header used to pass information about the client port. Relevant when the EMQX cluster is deployed behind a load-balancer."""

fields_ws_opts_proxy_port_header.label:
"""Proxy port header"""

overload_protection_enable.desc:
"""React on system overload or not."""

overload_protection_enable.label:
"""React on system overload or not"""

fields_mqtt_quic_listener_minimum_mtu.desc:
"""The minimum MTU supported by a connection. This will be used as the starting MTU. Default: 1248"""

fields_mqtt_quic_listener_minimum_mtu.label:
"""Minimum MTU"""

sys_msg_interval.desc:
"""Time interval of publishing `$SYS` messages."""

mqtt_await_rel_timeout.desc:
"""For client to broker QoS 2 message, the time limit for the broker to wait before the `PUBREL` message is received. The wait is aborted after timed out, meaning the packet ID is freed for new `PUBLISH` requests. Receiving a stale `PUBREL` causes a warning level log. Note, the message is delivered to subscribers before entering the wait for PUBREL."""

mqtt_await_rel_timeout.label:
"""Max Awaiting PUBREL TIMEOUT"""

common_ssl_opts_schema_verify.desc:
"""Enable or disable peer verification."""

common_ssl_opts_schema_verify.label:
"""Verify peer"""

fields_listeners_ssl.desc:
"""SSL listeners."""

fields_listeners_ssl.label:
"""SSL listeners"""

fields_deflate_opts_client_max_window_bits.desc:
"""Specifies the size of the compression context for the client."""

fields_deflate_opts_client_max_window_bits.label:
"""Client compression max window size"""

common_ssl_opts_schema_keyfile.desc:
"""PEM format private key file."""

common_ssl_opts_schema_keyfile.label:
"""Keyfile"""

sysmon_os_cpu_high_watermark.desc:
"""The threshold, as percentage of system CPU load,
 for how much system cpu can be used before the corresponding alarm is raised."""

sysmon_os_cpu_high_watermark.label:
"""CPU high watermark"""

flapping_detect_window_time.desc:
"""The time window for flapping detection."""

flapping_detect_window_time.label:
"""Window time"""

mqtt_mqueue_default_priority.desc:
"""Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>)."""

mqtt_mqueue_default_priority.label:
"""Default Topic Priorities"""

client_ssl_opts_schema_enable.desc:
"""Enable TLS."""

client_ssl_opts_schema_enable.label:
"""Enable TLS."""

fields_mqtt_quic_listener_mtu_discovery_missing_probe_count.desc:
"""The maximum number of stateless operations that may be queued on a binding at any one time. Default: 3"""

fields_mqtt_quic_listener_mtu_discovery_missing_probe_count.label:
"""MTU discovery missing probe count"""

fields_tcp_opts_recbuf.desc:
"""The TCP receive buffer (OS kernel) for the connections."""

fields_tcp_opts_recbuf.label:
"""TCP receive buffer"""

sysmon_vm_process_check_interval.desc:
"""The time interval for the periodic process limit check."""

sysmon_vm_process_check_interval.label:
"""Process limit check interval"""

fields_mqtt_quic_listener_server_resumption_level.desc:
"""Controls resumption tickets and/or 0-RTT server support. Default: 0 (No resumption)"""

fields_mqtt_quic_listener_server_resumption_level.label:
"""Server resumption level"""

fields_ws_opts_proxy_address_header.desc:
"""HTTP header used to pass information about the client IP address.
Relevant when the EMQX cluster is deployed behind a load-balancer."""

fields_ws_opts_proxy_address_header.label:
"""Proxy address header"""

sysmon_os_sysmem_high_watermark.desc:
"""The threshold, as percentage of system memory,
 for how much system memory can be allocated before the corresponding alarm is raised."""

sysmon_os_sysmem_high_watermark.label:
"""SysMem high wartermark"""

fields_tcp_opts_high_watermark.desc:
"""The socket is set to a busy state when the amount of data queued internally
by the VM socket implementation reaches this limit."""

fields_tcp_opts_high_watermark.label:
"""TCP high watermark"""

fields_mqtt_quic_listener_stateless_operation_expiration_ms.desc:
"""The time limit between operations for the same endpoint, in milliseconds. Default: 100"""

fields_mqtt_quic_listener_stateless_operation_expiration_ms.label:
"""Stateless operation expiration ms"""

server_ssl_opts_schema_dhfile.desc:
"""Path to a file containing PEM-encoded Diffie-Hellman parameters
to be used by the server if a cipher suite using Diffie-Hellman
key exchange is negotiated. If not specified, default parameters
are used.<br/>
NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."""

server_ssl_opts_schema_dhfile.label:
"""SSL dhfile"""

flapping_detect_max_count.desc:
"""The maximum number of disconnects allowed for a MQTT Client in `window_time`"""

flapping_detect_max_count.label:
"""Max count"""

mqtt_max_topic_levels.desc:
"""Maximum topic levels allowed."""

mqtt_max_topic_levels.label:
"""Max Topic Levels"""

force_shutdown_max_heap_size.desc:
"""Total heap size"""

force_shutdown_max_heap_size.label:
"""Total heap size"""

persistent_store_on_disc.desc:
"""Save information about the persistent sessions on disc.
If this option is enabled, persistent sessions will survive full restart of the cluster.
Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped."""

persistent_store_on_disc.label:
"""Persist on disc"""

mqtt_ignore_loop_deliver.desc:
"""Whether the messages sent by the MQTT v3.1.1/v3.1.0 client will be looped back to the publisher itself, similar to <code>No Local</code> in MQTT 5.0."""

mqtt_ignore_loop_deliver.label:
"""Ignore Loop Deliver"""

common_ssl_opts_schema_certfile.desc:
"""PEM format certificates chain file.<br/>
The certificates in this file should be in reversed order of the certificate
issue chain. That is, the host's certificate should be placed in the beginning
of the file, followed by the immediate issuer certificate and so on.
Although the root CA certificate is optional, it should be placed at the end of
the file if it is to be added."""

common_ssl_opts_schema_certfile.label:
"""Certfile"""

mqtt_exclusive_subscription.desc:
"""Whether to enable support for MQTT exclusive subscription."""

mqtt_exclusive_subscription.label:
"""Exclusive Subscription"""

mqtt_retain_available.desc:
"""Whether to enable support for MQTT retained message."""

mqtt_retain_available.label:
"""Retain Available"""

fields_tcp_opts_reuseaddr.desc:
"""The SO_REUSEADDR flag for the connections."""

fields_tcp_opts_reuseaddr.label:
"""SO_REUSEADDR"""

sysmon_vm_long_schedule.desc:
"""When the Erlang VM detect a task scheduled for too long, a warning level 'long_schedule' log is emitted,
and an MQTT message is published to the system topic <code>$SYS/sysmon/long_schedule</code>."""

sysmon_vm_long_schedule.label:
"""Enable Long Schedule monitoring."""

mqtt_keepalive_multiplier.desc:
"""Keep-Alive Timeout = Keep-Alive interval × Keep-Alive Multiplier.
The default value 1.5 is following the MQTT 5.0 specification. This multiplier is adjustable, providing system administrators flexibility for tailoring to their specific needs. For instance, if a client's 10-second Keep-Alive interval PINGREQ gets delayed by an extra 10 seconds, changing the multiplier to 2 lets EMQX tolerate this delay."""

mqtt_keepalive_multiplier.label:
"""Keep Alive Multiplier"""

force_gc_bytes.desc:
"""GC the process after specified number of bytes have passed through."""

force_gc_bytes.label:
"""Process GC bytes"""

server_ssl_opts_schema_fail_if_no_peer_cert.desc:
"""Used together with {verify, verify_peer} by an TLS/DTLS server.
If set to true, the server fails if the client does not have a
certificate to send, that is, sends an empty certificate.
If set to false, it fails only if the client sends an invalid
certificate (an empty certificate is considered valid)."""

server_ssl_opts_schema_fail_if_no_peer_cert.label:
"""SSL fail if no peer cert"""

fields_ws_opts_compress.desc:
"""If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/>
The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration."""

fields_ws_opts_compress.label:
"""Ws compress"""

fields_mqtt_quic_listener_keep_alive_interval.desc:
"""How often to send PING frames to keep a connection alive. 0 means disabled."""

fields_mqtt_quic_listener_keep_alive_interval.label:
"""Keep Alive Interval"""

fields_cache_ttl.desc:
"""Time to live for the cached data."""

fields_cache_ttl.label:
"""Time to live for the cached data."""

sys_topics.desc:
"""System topics configuration."""

sys_event_client_subscribed.desc:
"""Enable to publish event message that client subscribed a topic successfully."""

sysmon_top_db_port.desc:
"""Port of the PostgreSQL database that collects the data points."""

sysmon_top_db_port.label:
"""DB Port"""

fields_mqtt_quic_listener_max_operations_per_drain.desc:
"""The maximum number of operations to drain per connection quantum. Default: 16"""

fields_mqtt_quic_listener_max_operations_per_drain.label:
"""Max operations per drain"""

fields_mqtt_quic_listener_datagram_receive_enabled.desc:
"""Advertise support for QUIC datagram extension. Reserve for the future. Default 0 (FALSE)"""

fields_mqtt_quic_listener_datagram_receive_enabled.label:
"""Datagram receive enabled"""

fields_mqtt_quic_listener_initial_rtt_ms.desc:
"""Initial RTT estimate."""

fields_mqtt_quic_listener_initial_rtt_ms.label:
"""Initial RTT ms"""

overload_protection_backoff_gc.desc:
"""When at high load, skip forceful GC."""

overload_protection_backoff_gc.label:
"""Skip GC"""

broker_perf_route_lock_type.desc:
"""Performance tuning for subscribing/unsubscribing a wildcard topic.
Change this parameter only when there are many wildcard topics.

NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.
  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.
  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.
  - `global`: updates are protected with a global lock. Recommended for large clusters."""

fields_tcp_opts_nodelay.desc:
"""The TCP_NODELAY flag for the connections."""

fields_tcp_opts_nodelay.label:
"""TCP_NODELAY"""

fields_tcp_opts_keepalive.desc:
"""Enable TCP keepalive for MQTT connections over TCP or SSL.
The value is three comma separated numbers in the format of 'Idle,Interval,Probes'
 - Idle: The number of seconds a connection needs to be idle before the server begins to send out keep-alive probes (Linux default 7200).
 - Interval: The number of seconds between TCP keep-alive probes (Linux default 75).
 - Probes: The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end (Linux default 9).
For example "240,30,5" means: EMQX should start sending TCP keepalive probes after the connection is in idle for 240 seconds, and the probes are sent every 30 seconds until a response is received from the MQTT client, if it misses 5 consecutive responses, EMQX should close the connection.
Default: 'none'"""

fields_tcp_opts_keepalive.label:
"""TCP keepalive options"""

sysmon_top_db_username.desc:
"""Username of the PostgreSQL database"""

sysmon_top_db_username.label:
"""DB Username"""

broker.desc:
"""Message broker options."""

force_gc_count.desc:
"""GC the process after this many received messages."""

force_gc_count.label:
"""Process GC messages num"""

mqtt_max_clientid_len.desc:
"""Maximum allowed length of MQTT Client ID."""

mqtt_max_clientid_len.label:
"""Max Client ID Length"""

fields_ws_opts_supported_subprotocols.desc:
"""Comma-separated list of supported subprotocols."""

fields_ws_opts_supported_subprotocols.label:
"""Supported subprotocols"""

broker_shared_subscription_strategy.desc:
"""Dispatch strategy for shared subscription.
  - `random`: dispatch the message to a random selected subscriber
  - `round_robin`: select the subscribers in a round-robin manner
  - `round_robin_per_group`: select the subscribers in round-robin fashion within each shared subscriber group
  - `local`: select random local subscriber otherwise select random cluster-wide
  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.
  - `hash_clientid`: select the subscribers by hashing the `clientIds`
  - `hash_topic`: select the subscribers by hashing the source topic"""

fields_deflate_opts_mem_level.desc:
"""Specifies the size of the compression state.<br/>
Lower values decrease memory usage per connection."""

fields_deflate_opts_mem_level.label:
"""Size of the compression state"""

fields_mqtt_quic_listener_send_idle_timeout_ms.desc:
"""Reset congestion control after being idle for amount of time. Default: 1000"""

fields_mqtt_quic_listener_send_idle_timeout_ms.label:
"""Send idle timeout ms"""

base_listener_limiter.desc:
"""Type of the rate limit."""

base_listener_limiter.label:
"""Type of the rate limit."""

max_conn_rate.desc:
"""Maximum connection rate.<br/>
This is used to limit the connection rate for this listener,
once the limit is reached, new connections will be deferred or refused"""
max_conn_rate.label:
"""Maximum Connection Rate"""

messages_rate.desc:
"""Messages publish rate.<br/>
This is used to limit the inbound message numbers for each client connected to this listener,
once the limit is reached, the restricted client will slow down and even be hung for a while."""
messages_rate.label:
"""Messages Publish Rate"""

bytes_rate.desc:
"""Data publish rate.<br/>
This is used to limit the inbound bytes rate for each client connected to this listener,
once the limit is reached, the restricted client will slow down and even be hung for a while."""
bytes_rate.label:
"""Data Publish Rate"""

persistent_session_store_backend.desc:
"""Database management system used to store information about persistent sessions and messages.
- `builtin`: Use the embedded database (mria)"""

persistent_session_store_backend.label:
"""Backend"""

alarm_validity_period.desc:
"""Retention time of deactivated alarms. Alarms are not deleted immediately
when deactivated, but after the retention time."""

alarm_validity_period.label:
"""Alarm validity period"""

server_ssl_opts_schema_ocsp_issuer_pem.desc:
"""PEM-encoded certificate of the OCSP issuer for the server certificate."""

server_ssl_opts_schema_ocsp_issuer_pem.label:
"""OCSP Issuer Certificate"""

fields_tcp_opts_active_n.desc:
"""Specify the {active, N} option for this Socket.<br/>
See: https://erlang.org/doc/man/inet.html#setopts-2"""

fields_tcp_opts_active_n.label:
"""active_n"""

listener_authentication.desc:
"""Per-listener authentication override.
Authentication can be one single authenticator instance or a chain of authenticators as an array.
When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order."""

listener_authentication.label:
"""Per-listener authentication override"""

fields_trace_payload_encode.desc:
"""Determine the format of the payload format in the trace file.<br/>
`text`: Text-based protocol or plain text protocol.
 It is recommended when payload is JSON encoded.<br/>
`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br/>
`hidden`: payload is obfuscated as `******`"""

fields_trace_payload_encode.label:
"""Payload encode"""

mqtt_response_information.desc:
"""UTF-8 string, for creating the response topic, for example, if set to <code>reqrsp/</code>, the publisher/subscriber will communicate using the topic prefix <code>reqrsp/</code>.
To disable this feature, input <code>""</code> in the text box below. Only applicable to MQTT 5.0 clients."""

mqtt_response_information.label:
"""Response Information"""

persistent_session_store_max_retain_undelivered.desc:
"""The time messages that was not delivered to a persistent session
is stored before being garbage collected if the node the previous
session was handled on restarts of is stopped."""

persistent_session_store_max_retain_undelivered.label:
"""Max retain undelivered"""

fields_mqtt_quic_listener_migration_enabled.desc:
"""Enable clients to migrate IP addresses and tuples. Requires a cooperative load-balancer, or no load-balancer. Default: 1 (Enabled)"""

fields_mqtt_quic_listener_migration_enabled.label:
"""Migration enabled"""

common_ssl_opts_schema_password.desc:
"""String containing the user's password. Only used if the private key file is password-protected."""

common_ssl_opts_schema_password.label:
"""Keyfile passphrase"""

common_ssl_opts_schema_hibernate_after.desc:
"""Hibernate the SSL process after idling for amount of time reducing its memory footprint."""

common_ssl_opts_schema_hibernate_after.label:
"""hibernate after"""

fields_mqtt_quic_listener_send_buffering_enabled.desc:
"""Buffer send data instead of holding application buffers until sent data is acknowledged. Default: 1 (Enabled)"""

fields_mqtt_quic_listener_send_buffering_enabled.label:
"""Send buffering enabled"""

sys_event_client_unsubscribed.desc:
"""Enable to publish event message that client unsubscribed a topic successfully."""

overload_protection_backoff_new_conn.desc:
"""When at high load, close new incoming connections."""

overload_protection_backoff_new_conn.label:
"""Close new connections"""

server_ssl_opts_schema_ocsp_responder_url.desc:
"""URL for the OCSP responder to check the server certificate against."""

server_ssl_opts_schema_ocsp_responder_url.label:
"""OCSP Responder URL"""

mqtt_idle_timeout.desc:
"""Configure the duration of time that a connection can remain idle (i.e., without any data transfer) before being:
  - Automatically disconnected  if no CONNECT package is received from the client yet.
  - Put into hibernation mode to save resources if some CONNECT packages are already received.
Note: Please set the parameter with caution as long idle time will lead to resource waste."""

mqtt_idle_timeout.label:
"""Idle Timeout"""

fields_mqtt_quic_listener_conn_flow_control_window.desc:
"""Connection-wide flow control window. Default: 16777216"""

fields_mqtt_quic_listener_conn_flow_control_window.label:
"""Conn flow control window"""

fields_mqtt_quic_listener_maximum_mtu.desc:
"""The maximum MTU supported by a connection. This will be the maximum probed value. Default: 1500"""

fields_mqtt_quic_listener_maximum_mtu.label:
"""Maximum MTU"""

sysmon_top_db_name.desc:
"""PostgreSQL database name"""

sysmon_top_db_name.label:
"""DB Name"""

mqtt_strict_mode.desc:
"""Whether to parse MQTT messages in strict mode.
In strict mode, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected."""

mqtt_strict_mode.label:
"""Strict Mode"""

shared_subscription_group_strategy.desc:
"""Per group dispatch strategy for shared subscription.
This config is a map from shared subscription group name to the strategy
name. The group name should be of format `[A-Za-z0-9]`. i.e. no
special characters are allowed."""

fields_deflate_opts_strategy.desc:
"""Specifies the compression strategy."""

fields_deflate_opts_strategy.label:
"""compression strategy"""

shared_subscription_strategy_enum.desc:
"""Dispatch strategy for shared subscription.
- `random`: dispatch the message to a random selected subscriber
- `round_robin`: select the subscribers in a round-robin manner
- `round_robin_per_group`: select the subscribers in round-robin fashion within each shared subscriber group
- `sticky`: always use the last selected subscriber to dispatch,
until the subscriber disconnects.
- `hash`: select the subscribers by the hash of `clientIds`
- `local`: send to a random local subscriber. If local
subscriber was not found, send to a random subscriber cluster-wide"""

persistent_session_builtin_sess_msg_table.desc:
"""Performance tuning options for built-in session messages table."""

persistent_session_builtin_sess_msg_table.label:
"""Persistent session messages"""

mqtt_mqueue_store_qos0.desc:
"""Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains."""

mqtt_mqueue_store_qos0.label:
"""Store QoS 0 Message"""

server_ssl_opts_schema_client_renegotiation.desc:
"""In protocols that support client-initiated renegotiation,
the cost of resources of such an operation is higher for the server than the client.
This can act as a vector for denial of service attacks.
The SSL application already takes measures to counter-act such attempts,
but client-initiated renegotiation can be strictly disabled by setting this option to false.
The default value is true. Note that disabling renegotiation can result in
long-lived connections becoming unusable due to limits on
the number of messages the underlying cipher suite can encipher.</br>
Has no effect when TLS version is configured (or negotiated) to 1.3"""

server_ssl_opts_schema_client_renegotiation.label:
"""SSL client renegotiation"""

server_ssl_opts_schema_enable_crl_check.desc:
"""Whether to enable CRL verification for this listener."""

server_ssl_opts_schema_enable_crl_check.label:
"""Enable CRL Check"""

fields_mqtt_quic_listener_peer_bidi_stream_count.desc:
"""Number of bidirectional streams to allow the peer to open."""

fields_mqtt_quic_listener_peer_bidi_stream_count.label:
"""Peer bidi stream count"""

fields_mqtt_quic_listener_max_stateless_operations.desc:
"""The maximum number of stateless operations that may be queued on a worker at any one time. Default: 16"""

fields_mqtt_quic_listener_max_stateless_operations.label:
"""Max stateless operations"""

fields_ws_opts_idle_timeout.desc:
"""Close transport-layer connections from the clients that have not sent MQTT CONNECT message within this interval."""

fields_ws_opts_idle_timeout.label:
"""WS idle timeout"""

fields_mqtt_quic_listener_max_ack_delay_ms.desc:
"""How long to wait after receiving data before sending an ACK. Default: 25"""

fields_mqtt_quic_listener_max_ack_delay_ms.label:
"""Max ack delay ms"""

base_listener_zone.desc:
"""The configuration zone to which the listener belongs."""

base_listener_zone.label:
"""Zone"""

fields_mqtt_quic_listener_handshake_idle_timeout.desc:
"""How long a handshake can idle before it is discarded."""

fields_mqtt_quic_listener_handshake_idle_timeout.label:
"""Handshake Idle Timeout"""

force_gc_enable.desc:
"""Enable forced garbage collection."""

force_gc_enable.label:
"""Enable forced garbage collection"""

fields_ws_opts_allow_origin_absence.desc:
"""If <code>false</code> and <code>check_origin_enable</code> is
 <code>true</code>, the server will reject requests that don't have <code>origin</code>
 HTTP header."""

fields_ws_opts_allow_origin_absence.label:
"""Allow origin absence"""

common_ssl_opts_schema_versions.desc:
"""All TLS/DTLS versions to be supported.<br/>
NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>
In case PSK cipher suites are intended, make sure to configure
<code>['tlsv1.2', 'tlsv1.1']</code> here."""

common_ssl_opts_schema_versions.label:
"""SSL versions"""

mqtt_listener_proxy_protocol_timeout.desc:
"""Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""

mqtt_listener_proxy_protocol_timeout.label:
"""Proxy protocol timeout"""

fields_mqtt_quic_listener_idle_timeout.desc:
"""How long a connection can go idle before it is gracefully shut down. 0 to disable"""

fields_mqtt_quic_listener_idle_timeout.label:
"""Idle Timeout"""

common_ssl_opts_schema_secure_renegotiate.desc:
"""SSL parameter renegotiation is a feature that allows a client and a server
to renegotiate the parameters of the SSL connection on the fly.
RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
you drop support for the insecure renegotiation, prone to MitM attacks.</br>
Has no effect when TLS version is configured (or negotiated) to 1.3"""

common_ssl_opts_schema_secure_renegotiate.label:
"""SSL renegotiate"""

common_ssl_opts_schema_log_level.desc:
"""Log level for SSL communication. Default is 'notice'. Set to 'debug' to inspect TLS handshake messages."""
common_ssl_opts_schema_log_level.label:
"""SSL log level"""

sysmon_vm_busy_port.desc:
"""When a port (e.g. TCP socket) is overloaded, there will be a <code>busy_port</code> warning log,
and an MQTT message is published to the system topic <code>$SYS/sysmon/busy_port</code>."""

sysmon_vm_busy_port.label:
"""Enable Busy Port monitoring."""

sys_event_client_connected.desc:
"""Enable to publish client connected event messages"""

sysmon_vm_process_low_watermark.desc:
"""The threshold, as percentage of processes, for how many
 processes can simultaneously exist at the local node before the corresponding
 alarm is cleared."""

sysmon_vm_process_low_watermark.label:
"""Process low watermark"""

mqtt_max_packet_size.desc:
"""Maximum MQTT packet size allowed."""

mqtt_max_packet_size.label:
"""Max Packet Size"""

common_ssl_opts_schema_reuse_sessions.desc:
"""Enable TLS session reuse.</br>
Has no effect when TLS version is configured (or negotiated) to 1.3"""

common_ssl_opts_schema_reuse_sessions.label:
"""TLS session reuse"""

common_ssl_opts_schema_depth.desc:
"""Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.
So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>
if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>
if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA."""

common_ssl_opts_schema_depth.label:
"""CACert Depth"""

sysmon_vm_long_gc.desc:
"""When an Erlang process spends long time to perform garbage collection, a warning level <code>long_gc</code> log is emitted,
and an MQTT message is published to the system topic <code>$SYS/sysmon/long_gc</code>."""

sysmon_vm_long_gc.label:
"""Enable Long GC monitoring."""

fields_mqtt_quic_listener_keyfile.desc:
"""Path to the secret key file. Will be deprecated in 5.1, use .ssl_options.keyfile instead."""

fields_mqtt_quic_listener_keyfile.label:
"""Key file"""

mqtt_peer_cert_as_clientid.desc:
"""Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.
Supported configurations are the following:
- <code>cn</code>: CN field of the certificate
- <code>dn</code>: DN field of the certificate
- <code>crt</code>: <code>DER</code> or <code>PEM</code> certificate
- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format and use as Client ID
- <code>md5</code>: MD5 value of the <code>DER</code> or <code>PEM</code> certificate"""

mqtt_peer_cert_as_clientid.label:
"""Use Peer Certificate as Client ID"""

persistent_session_store_message_gc_interval.desc:
"""The starting interval for garbage collection of undelivered messages to
a persistent session. This affects how often the "max_retain_undelivered"
is checked for removal."""

persistent_session_store_message_gc_interval.label:
"""Message GC interval"""

broker_shared_dispatch_ack_enabled.desc:
"""Deprecated.
This was designed to avoid dispatching messages to a shared-subscription session which has the client disconnected.
However it's no longer useful because the shared-subscrption messages in a expired session will be redispatched to other sessions in the group."""

base_listener_enable_authn.desc:
"""Set <code>true</code> (default) to enable client authentication on this listener, the authentication
process goes through the configured authentication chain.
When set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.
When set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code>, but clients will be
denied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off
anonymous clients early."""

base_listener_enable_authn.label:
"""Enable authentication"""

force_shutdown_enable.desc:
"""Enable `force_shutdown` feature."""

force_shutdown_enable.label:
"""Enable `force_shutdown` feature"""

broker_enable_session_registry.desc:
"""Enable session registry"""

overload_protection_backoff_delay.desc:
"""The maximum duration of delay for background task execution during high load conditions."""

overload_protection_backoff_delay.label:
"""Delay Time"""

ciphers_schema_common.desc:
"""This config holds TLS cipher suite names separated by comma,
or as an array of strings. e.g.
<code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
<code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
<br/>
Ciphers (and their ordering) define the way in which the
client and server encrypts information over the network connection.
Selecting a good cipher suite is critical for the
application's data security, confidentiality and performance.

The names should be in OpenSSL string format (not RFC format).
All default values and examples provided by EMQX config
documentation are all in OpenSSL format.<br/>

NOTE: Certain cipher suites are only compatible with
specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
incompatible cipher suites will be silently dropped.
For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
configuring cipher suites for other versions will have no effect.
<br/>

NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>
If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>
PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code>"""

ciphers_schema_common.label:
""""""

sys_event_client_disconnected.desc:
"""Enable to publish client disconnected event messages."""

crl_cache_refresh_interval.desc:
"""The period to refresh the CRLs from the servers.  This is a global setting for all URLs and listeners."""

crl_cache_refresh_interval.label:
"""CRL Cache Refresh Interval"""

mqtt_listener_proxy_protocol.desc:
"""Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""

mqtt_listener_proxy_protocol.label:
"""Proxy protocol"""

mqtt_listener_access_rules.desc:
"""The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny"""

mqtt_listener_access_rules.label:
"""Access rules"""

server_ssl_opts_schema_enable_ocsp_stapling.desc:
"""Whether to enable Online Certificate Status Protocol (OCSP) stapling for the listener.  If set to true, requires defining the OCSP responder URL and issuer PEM path."""

server_ssl_opts_schema_enable_ocsp_stapling.label:
"""Enable OCSP Stapling"""

fields_tcp_opts_send_timeout_close.desc:
"""Close the connection if send timeout."""

fields_tcp_opts_send_timeout_close.label:
"""TCP send timeout close"""

sysmon_os_cpu_check_interval.desc:
"""The time interval for the periodic CPU check."""

sysmon_os_cpu_check_interval.label:
"""The time interval for the periodic CPU check."""

sysmon_top_sample_interval.desc:
"""Specifies how often process top should be collected"""

sysmon_top_sample_interval.label:
"""Top sample interval"""

fields_mqtt_quic_listener_idle_timeout_ms.desc:
"""How long a connection can go idle before it is gracefully shut down. 0 to disable timeout"""

fields_mqtt_quic_listener_idle_timeout_ms.label:
"""Idle timeout ms"""

fields_ws_opts_fail_if_no_subprotocol.desc:
"""If <code>true</code>, the server will return an error when
 the client does not carry the <code>Sec-WebSocket-Protocol</code> field.
 <br/>Note: WeChat applet needs to disable this verification."""

fields_ws_opts_fail_if_no_subprotocol.label:
"""Fail if no subprotocol"""

mqtt_wildcard_subscription.desc:
"""Whether to enable support for MQTT wildcard subscription."""

mqtt_wildcard_subscription.label:
"""Wildcard Subscription Available"""

server_ssl_opts_schema_ocsp_refresh_interval.desc:
"""The period to refresh the OCSP response for the server."""

server_ssl_opts_schema_ocsp_refresh_interval.label:
"""OCSP Refresh Interval"""

overload_protection_backoff_hibernation.desc:
"""When at high load, skip process hibernation."""

overload_protection_backoff_hibernation.label:
"""Skip hibernation"""

fields_ws_opts_max_frame_size.desc:
"""The maximum length of a single MQTT packet."""

fields_ws_opts_max_frame_size.label:
"""Max frame size"""

sys_event_messages.desc:
"""Client events messages."""

broker_perf_trie_compaction.desc:
"""Enable trie path compaction.
Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.
Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.

NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it."""

sysmon_vm_large_heap.desc:
"""When an Erlang process consumed a large amount of memory for its heap space,
the system will write a warning level <code>large_heap</code> log, and an MQTT message is published to
the system topic <code>$SYS/sysmon/large_heap</code>."""

sysmon_vm_large_heap.label:
"""Enable Large Heap monitoring."""

}

emqx_slow_subs_api {

clear_records_api.desc:
"""Clear current data and re count slow topic"""
clear_records_api.label:
"""Clear current data and re count slow topic"""

clientid.desc:
"""Message clientid"""

get_records_api.desc:
"""View slow topics statistics record data"""
get_records_api.label:
"""View slow topics statistics record data"""

get_setting_api.desc:
"""View slow subs settings"""
get_setting_api.label:
"""View slow subs settings"""

last_update_time.desc:
"""The timestamp of last update"""

node.desc:
"""Message node name"""

timespan.desc:
"""Timespan for message transmission"""

topic.desc:
"""Message topic"""

update_setting_api.desc:
"""Update slow subs settings"""
update_setting_api.label:
"""Update slow subs settings"""

}

emqx_slow_subs_schema {

enable.desc:
"""Enable this feature"""

expire_interval.desc:
"""The eviction time of the record, which in the statistics record table"""

stats_type.desc:
"""The method to calculate the latency"""

threshold.desc:
"""The latency threshold for statistics"""

top_k_num.desc:
"""The maximum number of records in the slow subscription statistics record table"""

}

emqx_stomp_schema {

stom_frame_max_body_length.desc:
"""Maximum number of bytes of Body allowed per Stomp packet"""

stom_frame_max_headers.desc:
"""The maximum number of Header"""

stomp.desc:
"""The Stomp Gateway configuration.
This gateway supports v1.2/1.1/1.0"""

stomp_frame_max_headers_length.desc:
"""The maximum string length of the Header Value"""

}

emqx_telemetry_api {

active_modules.desc:
"""Get active modules"""

active_plugins.desc:
"""Get active plugins"""

emqx_version.desc:
"""Get emqx version"""

enable.desc:
"""Enable telemetry"""

get_telemetry_data_api.desc:
"""Get telemetry data"""
get_telemetry_data_api.label:
"""Get telemetry data"""

get_telemetry_status_api.desc:
"""Get telemetry status"""
get_telemetry_status_api.label:
"""Get telemetry status"""

license.desc:
"""Get license information"""

messages_received.desc:
"""Get number of messages received"""

messages_sent.desc:
"""Get number of messages sent"""

nodes_uuid.desc:
"""Get nodes UUID"""

num_clients.desc:
"""Get number of clients"""

os_name.desc:
"""Get OS name"""

os_version.desc:
"""Get OS version"""

otp_version.desc:
"""Get Erlang OTP version"""

up_time.desc:
"""Get uptime"""

update_telemetry_status_api.desc:
"""Enable or disable telemetry"""
update_telemetry_status_api.label:
"""Enable or disable telemetry"""

uuid.desc:
"""Get UUID"""

}

emqx_telemetry_schema {
telemetry_root_doc.desc:
"""Configure telemetry data report from this EMQX node to EMQ's telemetry data collection server.
See https://www.emqx.io/docs/en/v5.0/telemetry/telemetry.html for more details."""

enable.desc:
"""Set to `false` disable telemetry data report"""
}

emqx_topic_metrics_api {

message_qos1_in_rate.desc:
"""QoS1 in messages rate"""
message_qos1_in_rate.label:
"""QoS1 in messages rate"""

message_out_count.desc:
"""Out messages count"""
message_out_count.label:
"""Out messages count"""

message_qos2_out_rate.desc:
"""QoS2 out messages rate"""
message_qos2_out_rate.label:
"""QoS2 out messages rate"""

message_qos0_in_rate.desc:
"""QoS0 in messages rate"""
message_qos0_in_rate.label:
"""QoS0 in messages rate"""

get_topic_metrics_api.desc:
"""List topic metrics"""
get_topic_metrics_api.label:
"""List topic metrics"""

reset_time.desc:
"""Reset time. In rfc3339. Nullable if never reset"""
reset_time.label:
"""Reset time"""

topic_metrics_api_response400.desc:
"""Bad request. Already exists or bad topic name"""
topic_metrics_api_response400.label:
"""Bad request"""

reset_topic_desc.desc:
"""Topic Name. If this parameter is not present,all created topic metrics will be reset."""
reset_topic_desc.label:
"""Topic Name"""

topic_metrics_api_response409.desc:
"""Conflict. Topic metrics exceeded max limit 512"""
topic_metrics_api_response409.label:
"""Conflict"""

post_topic_metrics_api.desc:
"""Create topic metrics"""
post_topic_metrics_api.label:
"""Create topic metrics"""

message_dropped_rate.desc:
"""Dropped messages rate"""
message_dropped_rate.label:
"""Dropped messages rate"""

message_qos2_in_rate.desc:
"""QoS2 in messages rate"""
message_qos2_in_rate.label:
"""QoS2 in messages rate"""

message_in_rate.desc:
"""In messages rate"""
message_in_rate.label:
"""In messages rate"""

message_qos0_out_rate.desc:
"""QoS0 out messages rate"""
message_qos0_out_rate.label:
"""QoS0 out messages rate"""

message_qos2_in_count.desc:
"""QoS2 in messages count"""
message_qos2_in_count.label:
"""QoS2 in messages count"""

message_dropped_count.desc:
"""Dropped messages count"""
message_dropped_count.label:
"""Dropped messages count"""

topic_metrics_api_response404.desc:
"""Not Found. Topic metrics not found"""
topic_metrics_api_response404.label:
"""Not Found"""

topic_in_path.desc:
"""Topic string. Notice: Topic string in url path must be encoded"""
topic_in_path.label:
"""Topic string"""

action.desc:
"""Action. Only support reset"""
action.label:
"""Action"""

message_qos0_in_count.desc:
"""QoS0 in messages count"""
message_qos0_in_count.label:
"""QoS0 in messages count"""

message_qos1_out_rate.desc:
"""QoS1 out messages rate"""
message_qos1_out_rate.label:
"""QoS1 out messages rate"""

topic.desc:
"""Topic"""
topic.label:
"""Topic"""

reset_topic_metrics_api.desc:
"""Reset telemetry status"""
reset_topic_metrics_api.label:
"""Reset telemetry status"""

create_time.desc:
"""Create time"""
create_time.label:
"""Create time"""

metrics.desc:
"""Metrics"""
metrics.label:
"""Metrics"""

message_qos1_out_count.desc:
"""QoS1 out messages count"""
message_qos1_out_count.label:
"""QoS1 out messages count"""

gat_topic_metrics_data_api.desc:
"""Get topic metrics"""
gat_topic_metrics_data_api.label:
"""Get topic metrics"""

message_qos1_in_count.desc:
"""QoS1 in messages count"""
message_qos1_in_count.label:
"""QoS1 in messages count"""

delete_topic_metrics_data_api.desc:
"""Delete topic metrics"""
delete_topic_metrics_data_api.label:
"""Delete topic metrics"""

message_qos0_out_count.desc:
"""QoS0 out messages count"""
message_qos0_out_count.label:
"""QoS0 out messages count"""

topic_in_body.desc:
"""Raw topic string"""
topic_in_body.label:
"""Raw topic string"""

message_in_count.desc:
"""In messages count"""
message_in_count.label:
"""In messages count"""

message_qos2_out_count.desc:
"""QoS2 out messages count"""
message_qos2_out_count.label:
"""QoS2 out messages count"""

message_out_rate.desc:
"""Out messages rate"""
message_out_rate.label:
"""Out messages rate"""

}
